import { Result } from "true-myth";
import * as ad from "../types/ad.js";
import { A, AbstractNode, C, Identifier, NodeType, SourceLoc, SourceRange } from "../types/ast.js";
import { Arg, Type, TypeConstructor } from "../types/domain.js";
import { ArgLengthMismatch, BadArgumentTypeError, BadShapeParamTypeError, CyclicSubtypes, DeconstructNonconstructor, DomainError, DuplicateName, FatalError, FunctionInternalError, InvalidColorLiteral, MissingArgumentError, NaNError, NotStyleVariableError, NotSubstanceCollectionError, ParseError, PenroseError, RedeclareNamespaceError, RuntimeError, SelectorFieldNotSupported, StyleError, StyleErrorList, StyleWarning, SubstanceError, SymmetricArgLengthMismatch, SymmetricTypeMismatch, TooManyArgumentsError, TypeArgLengthMismatch, TypeMismatch, TypeNotFound, UnexpectedExprForNestedPred, VarNotFound } from "../types/errors.js";
import { CompFunc, ConstrFunc, FuncParam, ObjFunc } from "../types/functions.js";
import { State } from "../types/state.js";
import { BindingForm, ColorLit } from "../types/style.js";
import { Deconstructor, SubExpr } from "../types/substance.js";
import { ArgValWithSourceLoc, ShapeVal, Val } from "../types/value.js";
import { ErrorLoc } from "./Util.js";
declare const or: typeof import("true-myth/result.js").or, and: typeof import("true-myth/result.js").and, ok: typeof import("true-myth/result.js").ok, err: typeof import("true-myth/result.js").err, andThen: typeof import("true-myth/result.js").andThen, match: typeof import("true-myth/result.js").match, ap: typeof import("true-myth/result.js").ap, unsafelyUnwrap: typeof import("true-myth/result.js").unsafelyUnwrap, isErr: typeof import("true-myth/result.js").isErr, unsafelyGetErr: typeof import("true-myth/result.js").unsafelyUnwrapErr;
/**
 * Type pretty printing function.
 * @param t Type to be printed
 */
export declare const showType: (t: Type<A>) => string;
export declare const styWarnings: string[];
export declare const showError: (error: DomainError | SubstanceError | StyleError | StyleWarning | RuntimeError) => string;
export declare const errLocs: (e: Exclude<DomainError | SubstanceError | StyleError | StyleWarning | RuntimeError, StyleErrorList>) => ErrorLoc[];
export declare const cyclicSubtypes: (cycles: string[][]) => CyclicSubtypes;
export declare const duplicateName: (name: Identifier<A>, location: AbstractNode, firstDefined: AbstractNode) => DuplicateName;
export declare const typeNotFound: (typeName: Identifier<A>, possibleTypes?: Identifier<A>[]) => TypeNotFound;
export declare const varNotFound: (variable: Identifier<A>, possibleVars?: Identifier<A>[]) => VarNotFound;
export declare const symmetricTypeMismatch: (sourceExpr: AbstractNode) => SymmetricTypeMismatch;
export declare const symmetricArgLengthMismatch: (sourceExpr: AbstractNode) => SymmetricArgLengthMismatch;
export declare const typeMismatch: (sourceType: TypeConstructor<A>, expectedType: TypeConstructor<A>, sourceExpr: AbstractNode, expectedExpr: AbstractNode) => TypeMismatch;
export declare const unexpectedExprForNestedPred: (sourceType: TypeConstructor<A>, sourceExpr: AbstractNode, expectedExpr: AbstractNode) => UnexpectedExprForNestedPred;
export declare const argLengthMismatch: (name: Identifier<A>, argsGiven: SubExpr<A>[], argsExpected: Arg<A>[], sourceExpr: AbstractNode, expectedExpr: AbstractNode) => ArgLengthMismatch;
export declare const typeArgLengthMismatch: (sourceType: TypeConstructor<A>, expectedType: TypeConstructor<A>, sourceExpr: AbstractNode, expectedExpr: AbstractNode) => TypeArgLengthMismatch;
export declare const selectorFieldNotSupported: (name: BindingForm<A>, field: Identifier<A>) => SelectorFieldNotSupported;
export declare const deconstructNonconstructor: (deconstructor: Deconstructor<A>) => DeconstructNonconstructor;
export declare const fatalError: (message: string) => FatalError;
export declare const parseError: (message: string, location?: SourceLoc, fileType?: NodeType) => ParseError;
export declare const invalidColorLiteral: (color: ColorLit<C>) => InvalidColorLiteral;
export declare const badShapeParamTypeError: (path: string, value: Val<ad.Num> | ShapeVal<ad.Num>, expectedType: string, passthrough: boolean) => BadShapeParamTypeError;
export declare const badArgumentTypeError: (funcName: string, funcArg: FuncParam, provided: ArgValWithSourceLoc<ad.Num>) => BadArgumentTypeError;
export declare const missingArgumentError: (funcName: string, funcArg: FuncParam, funcLocation: SourceRange) => MissingArgumentError;
export declare const tooManyArgumentsError: (func: CompFunc | ObjFunc | ConstrFunc, funcLocation: SourceRange, numProvided: number) => TooManyArgumentsError;
export declare const functionInternalError: (func: CompFunc | ObjFunc | ConstrFunc, location: SourceRange, message: string) => FunctionInternalError;
export declare const redeclareNamespaceError: (existingNamespace: string, location: SourceRange) => RedeclareNamespaceError;
export declare const notSubstanceCollectionError: (name: string, location: SourceRange) => NotSubstanceCollectionError;
export declare const notStyleVariableError: (name: string, location: SourceRange) => NotStyleVariableError;
export declare const nanError: (message: string, lastState: State) => NaNError;
export declare const toStyleErrors: (errors: StyleError[]) => PenroseError;
export declare const genericStyleError: (messages: StyleError[]) => PenroseError;
export declare const every: <Ok, Error_1>(...results: Result<Ok, Error_1>[]) => Result<Ok, Error_1>;
export declare const safeChain: <Item, Ok, Error_1>(itemList: Item[], func: (nextItem: Item, currentResult: Ok) => Result<Ok, Error_1>, initialResult: Result<Ok, Error_1>) => Result<Ok, Error_1>;
export declare const all: <Ok, Error_1>(results: Result<Ok, Error_1>[]) => Result<Ok[], Error_1[]>;
export { Result, and, andThen, ap, err, isErr, match, ok, or, unsafelyGetErr, unsafelyUnwrap, };
//# sourceMappingURL=Error.d.ts.map