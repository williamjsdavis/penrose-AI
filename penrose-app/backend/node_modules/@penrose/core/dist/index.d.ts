import { PathResolver } from "./renderer/Renderer.js";
import { PenroseError } from "./types/errors.js";
import { Fn, State } from "./types/state.js";
import { Result } from "./utils/Error.js";
/**
 * Use the current resample seed to sample all shapes in the State.
 * @param state current state
 */
export declare const resample: (state: State) => State;
/**
 * Take steps in the optimizer until either `until` evaluates to `true`, or the optimizer reaches convergence.
 * @param state current state
 * @param options `until` is a function that returns the early-stop condition.
 */
export declare const step: (state: State, options: {
    until: () => boolean;
}) => Result<State, PenroseError>;
/**
 * Take n steps in the optimizer given the current state.
 * @param state current state
 * @param numSteps number of steps to take (default: 10000)
 */
export declare const stepTimes: (state: State, numSteps?: number) => Result<State, PenroseError>;
/**
 * Move the current state to the next layout stage. If the current state is already at the final stage, return the current state.
 * @param state current state
 */
export declare const nextStage: (state: State) => State;
/**
 * Run the optimizer on the current state until the current layout stage converges.
 * @param state current state
 */
export declare const stepNextStage: (state: State) => Result<State, PenroseError>;
/**
 * Run the optimizer on the current state until it converges.
 * @param state current state
 */
export declare const optimize: (state: State) => Result<State, PenroseError>;
/**
 * Embed a static Penrose diagram in a DOM node.
 *
 * @param prog a Penrose trio and variation
 * @param node a node in the DOM tree
 * @param pathResolver a resolver function for fetching Style imports
 * @param name the name of the diagram
 */
export declare const diagram: (prog: {
    substance: string;
    style: string;
    domain: string;
    variation: string;
    excludeWarnings: string[];
}, node: HTMLElement, pathResolver: PathResolver, name?: string) => Promise<void>;
/**
 * Embed an interactive Penrose diagram in a DOM node.
 *
 * @param prog a Penrose trio and variation
 * @param pathResolver a resolver function for fetching Style imports
 * @param node a node in the DOM tree
 * @param name the name of the diagram
 */
export declare const interactiveDiagram: (prog: {
    substance: string;
    style: string;
    domain: string;
    variation: string;
    excludeWarnings: string[];
}, node: HTMLElement, pathResolver: PathResolver, name?: string) => Promise<void>;
/**
 * Given a trio of Domain, Substance, and Style programs, compile them into an initial `State`.
 * @param domainProg a Domain program string
 * @param subProg a Substance program string
 * @param styProg a Style program string
 */
export declare const compile: (prog: {
    substance: string;
    style: string;
    domain: string;
    variation: string;
    excludeWarnings?: string[];
}) => Promise<Result<State, PenroseError>>;
/**
 * Returns true if state is optimized
 * @param state current state
 */
export declare const isOptimized: (state: State) => boolean;
/**
 * Returns true if state results in an error
 * @param state current state
 */
export declare const isError: (state: State) => boolean;
/**
 * Returns true if the diagram state is on the last layout stage in the layout pipeline
 * @param state current state
 */
export declare const finalStage: (state: State) => boolean;
/**
 * Returns true if state is the initial frame
 * @param state current state
 */
export declare const isInitial: (state: State) => boolean;
/**
 * Evaluate the overall energy of a `State`.
 * @param s a state
 * @returns a scalar value of the current energy
 */
export declare const evalEnergy: (s: State) => number;
/**
 * Evaluate a list of constraints/objectives.
 * @param s a state
 * @returns a list of the energies of the requested functions, evaluated at the `varyingValues` in the `State`
 */
export declare const evalFns: (s: State) => {
    constrEngs: number[];
    objEngs: number[];
};
export type PenroseState = State;
export type PenroseFn = Fn;
export * from "./api.js";
export { checkDomain, compileDomain, parseDomain } from "./compiler/Domain.js";
export { checkSubstance, compileSubstance, parseSubstance, prettyCompiledSubstance, prettySubstance, } from "./compiler/Substance.js";
export { constrDict } from "./contrib/Constraints.js";
export { compDict } from "./contrib/Functions.js";
export { objDict } from "./contrib/Objectives.js";
export { toInteractiveSVG, toSVG } from "./renderer/Renderer.js";
export type { PathResolver } from "./renderer/Renderer.js";
export { makeCanvas, simpleContext } from "./shapes/Samplers.js";
export type { Canvas } from "./shapes/Samplers.js";
export { sampleShape, shapeTypes } from "./shapes/Shapes.js";
export type { ShapeType } from "./shapes/Shapes.js";
export type { Env } from "./types/domain.js";
export type { PenroseError, Warning as PenroseWarning, } from "./types/errors.js";
export type { CompFunc } from "./types/functions.js";
export type { SubProg } from "./types/substance.js";
export * as Value from "./types/value.js";
export { errLocs, showError } from "./utils/Error.js";
export type { Result } from "./utils/Error.js";
export { allWarnings, describeType, hexToRgba, prettyPrintExpr, prettyPrintFn, prettyPrintPath, rgbaToHex, zip2, } from "./utils/Util.js";
//# sourceMappingURL=index.d.ts.map