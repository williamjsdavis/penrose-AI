import { Circle } from "../shapes/Circle.js";
import { Ellipse } from "../shapes/Ellipse.js";
import { Group } from "../shapes/Group.js";
import { Line } from "../shapes/Line.js";
import { Path } from "../shapes/Path.js";
import { Polygon } from "../shapes/Polygon.js";
import { Polyline } from "../shapes/Polyline.js";
import { Context } from "../shapes/Samplers.js";
import { Shape } from "../shapes/Shapes.js";
import * as ad from "../types/ad.js";
import { MayWarn } from "../types/functions.js";
import { ClipDataV, Color, ColorV, FloatV, LListV, ListV, MatrixV, PathDataV, PtListV, TupV, VectorV } from "../types/value.js";
import { Rectlike } from "./Utils.js";
/**
 * Static dictionary of computation functions
 * TODO: consider using `Dictionary` type so all runtime lookups are type-safe, like here https://codeburst.io/five-tips-i-wish-i-knew-when-i-started-with-typescript-c9e8609029db
 * TODO: think about user extension of computation dict and evaluation of functions in there
 */
export declare const compDict: {
    makePath: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, start: [ad.Num, ad.Num], end: [ad.Num, ad.Num], curveHeight: ad.Num, padding: ad.Num) => MayWarn<PathDataV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `i`th element of list `xs, assuming lists only hold floats.
     */
    get: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, xs: ad.Num[], i: number) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return a paint color of elements `r`, `g`, `b`, `a` (red, green, blue, opacity).
     */
    rgba: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, r: ad.Num, g: ad.Num, b: ad.Num, a: ad.Num) => MayWarn<ColorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    selectColor: {
        name: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, color1: Color<ad.Num>, color2: Color<ad.Num>, level: ad.Num) => MayWarn<ColorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return a paint color of elements `h`, `s`, `v`, `a` (hue, saturation, value, opacity).
     */
    hsva: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, h: ad.Num, s: ad.Num, v: ad.Num, a: ad.Num) => MayWarn<ColorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return a paint of none (no paint)
     */
    none: {
        name: string;
        description: string;
        params: never[];
        body: (_context: Context) => MayWarn<ColorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    oneBasedElement: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][], i: number) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `acosh(x)`.
     */
    acosh: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `acos(x)`.
     */
    acos: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `asin(x)`.
     */
    asin: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `asinh(x)`.
     */
    asinh: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `mod(a, n)`.
     */
    mod: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, a: ad.Num, n: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `atan(x)`.
     */
    atan: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `atan2(y,x)`.
     */
    atan2: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num, y: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `atanh(x)`.
     */
    atanh: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `cbrt(x)`.
     */
    cbrt: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `ceil(x)`.
     */
    ceil: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `cos(x)`.
     */
    cos: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `cosh(x)`.
     */
    cosh: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `exp(x)`.
     */
    exp: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `expm1(x)`.
     */
    expm1: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `floor(x)`.
     */
    floor: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `log(x)`.
     */
    log: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `log2(x)`.
     */
    log2: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `log10(x)`.
     */
    log10: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `log1p(x)`.
     */
    log1p: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `pow(x,y)`.
     */
    pow: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num, y: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `round(x)`.
     */
    round: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `sign(x)`.
     */
    sign: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `sin(x)`.
     */
    sin: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `sinh(x)`.
     */
    sinh: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `tan(x)`.
     */
    tan: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `tanh(x)`.
     */
    tanh: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return `trunc(x)`.
     */
    trunc: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    sum: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, xs: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    sumVectors: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, vecs: ad.Num[][]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    maxList: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, xs: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    minList: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, xs: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    count: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, xs: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the dot product of `v` and `w`.
     */
    dot: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, v: ad.Num[], w: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    identity: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, n: number) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    diagonal: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, v: ad.Num[]) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    trace: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, A: ad.Num[][]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    determinant: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, A: ad.Num[][]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    inverse: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, A: ad.Num[][]) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    outerProduct: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, u: ad.Num[], v: ad.Num[]) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    crossProductMatrix: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, v: ad.Num[]) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    matrix: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, a: ad.Num, b: ad.Num, c: ad.Num, d: ad.Num, e: ad.Num, f: ad.Num) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    matrix3d: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, a1: ad.Num, b1: ad.Num, c1: ad.Num, d1: ad.Num, a2: ad.Num, b2: ad.Num, c2: ad.Num, d2: ad.Num, a3: ad.Num, b3: ad.Num, c3: ad.Num, d3: ad.Num, a4: ad.Num, b4: ad.Num, c4: ad.Num, d4: ad.Num) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rotate: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (_context: Context, theta: ad.Num, x: ad.Num, y: ad.Num) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rotate2d: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, theta: ad.Num) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rotate3d: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, theta: ad.Num, v: ad.Num[]) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rotate3dh: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, theta: ad.Num, v: ad.Num[]) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    scale: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, sx: ad.Num, sy: ad.Num) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    scale2d: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, sx: ad.Num, sy: ad.Num) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    scale3d: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, sx: ad.Num, sy: ad.Num, sz: ad.Num) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    scale3dh: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, sx: ad.Num, sy: ad.Num, sz: ad.Num) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    skew: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (_context: Context, ax: ad.Num, ay: ad.Num) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    skew2d: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (_context: Context, ax: ad.Num, ay: ad.Num) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    shear: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, u: ad.Num[], v: ad.Num[]) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    shear2d: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, u: ad.Num[], v: ad.Num[]) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    shear3d: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, u: ad.Num[], v: ad.Num[]) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    translate: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (_context: Context, x: ad.Num, y: ad.Num) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    translate3dh: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, x: ad.Num, y: ad.Num, z: ad.Num) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    lookAt: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, eye: ad.Num[], center: ad.Num[], up: ad.Num[]) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    perspective: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (_context: Context, fovy: ad.Num, aspect: ad.Num, zNear: ad.Num, zFar: ad.Num) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    ortho: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (_context: Context, Left: ad.Num, Right: ad.Num, Bottom: ad.Num, Top: ad.Num, zNear: ad.Num, zFar: ad.Num) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    project: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, p: ad.Num[], model: ad.Num[][], proj: ad.Num[][], view: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    projectDepth: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, p: ad.Num[], model: ad.Num[][], proj: ad.Num[][], view: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    projectList: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, p: ad.Num[][], model: ad.Num[][], proj: ad.Num[][], view: ad.Num[]) => MayWarn<PtListV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    matrixMultiplyList: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, A: ad.Num[][], V: ad.Num[][]) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    fromHomogeneous: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, q: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    fromHomogeneousList: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, Q: ad.Num[][]) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    toHomogeneous: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, p: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    toHomogeneousList: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, P: ad.Num[][]) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    toHomogeneousMatrix: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, A: ad.Num[][]) => MayWarn<MatrixV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the length of the line or arrow shape `[type, props]`.
     */
    length: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ShapeT;
        }[];
        body: (_context: Context, shape: Line<ad.Num>) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the normalized version of vector `v`.
     */
    normalize: {
        name: string;
        description: string;
        params: {
            type: import("../types/types.js").ValueT;
            name: string;
            description: string;
        }[];
        body: (_context: Context, v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Given a list of points `pts`, returns a `PathData` that can be used as input to the `Path` shape's `pathData` attribute to be drawn on the screen.
     */
    pathFromPoints: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, pathType: string, pts: ad.Pt2[]) => MayWarn<PathDataV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Given a list of points `pts`, returns a `PathData` that can be used as input to the `Path` shape's `pathData` attribute to be drawn on the screen.
     */
    quadraticCurveFromPoints: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, pathType: string, pts: ad.Pt2[]) => MayWarn<PathDataV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Draw a curve interpolating three given points.
     * (Note that this is different from specifying the
     * three control points of a quadratic Bézier curve,
     * since a Bézier does not interpolate the middle
     * control point.)
     */
    interpolateQuadraticFromPoints: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, pathType: string, p0: ad.Pt2, p1: ad.Pt2, p2: ad.Pt2) => MayWarn<PathDataV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Given a list of points `pts`, returns a `PathData` that can be used as input to the `Path` shape's `pathData` attribute to be drawn on the screen.
     */
    cubicCurveFromPoints: {
        name: string;
        description: string;
        params: {
            type: import("../types/types.js").ValueT;
            name: string;
            description: string;
        }[];
        body: (_context: Context, pathType: string, pts: ad.Pt2[]) => MayWarn<PathDataV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    Penrose: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default: number[];
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default: number;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default: string;
        })[];
        body: (_context: Context, center: ad.Num[], radius: ad.Num, holeSize: ad.Num, angle: ad.Num, nSides: number, chirality: string) => MayWarn<PathDataV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    firstPoint: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    lastPoint: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    averagePoint: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    interpolatingSpline: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default: number;
        })[];
        body: (_context: Context, pathType: string, points: ad.Num[][], tension: ad.Num) => MayWarn<PathDataV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    diffusionProcess: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, n: number, X0: ad.Num[], A: ad.Num[][], omega: ad.Num[]) => MayWarn<PtListV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return two points parallel to line `s1` using its normal line `s2`.
     */
    unitMark: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
        })[];
        body: (_context: Context, s1: Line<ad.Num>, s2: Line<ad.Num>, padding: ad.Num) => MayWarn<PtListV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return two points to "cap off" the line made in `unitMark`.
     */
    unitMark2: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, [start, end]: [ad.Pt2, ad.Pt2], t: string, size: ad.Num) => MayWarn<PtListV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return series of elements that can render an arc SVG. See: https://css-tricks.com/svg-path-syntax-illustrated-guide/ for the "A" spec.
     * @param pathType: either "open" or "closed." whether the SVG should automatically draw a line between the final point and the start point
     * @param start: coordinate to start drawing the arc
     * @param end: coordinate to finish drawing the arc
     * @param radius: width and height of the ellipse to draw the arc along (i.e. [width, height])
     * @param rotation: angle in degrees to rotate ellipse about its center
     * @param largeArc: 0 to draw shorter of 2 arcs, 1 to draw longer
     * @param arcSweep: 0 to rotate CCW, 1 to rotate CW
     * @returns: Elements that can be passed to Path shape spec to render an SVG arc
     */
    arc: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, pathType: string, start: ad.Pt2, end: ad.Pt2, radius: ad.Pt2, rotation: ad.Num, largeArc: ad.Num, arcSweep: ad.Num) => MayWarn<PathDataV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    circularArc: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, pathType: string, center: ad.Pt2, r: ad.Num, theta0: ad.Num, theta1: ad.Num) => MayWarn<PathDataV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    repeatedArcs: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, innerStart: ad.Pt2, innerEnd: ad.Pt2, outerStart: ad.Pt2, outerEnd: ad.Pt2, innerRadius: ad.Pt2, repeat: number, spacing: ad.Num, arcSweep: ad.Num) => MayWarn<PathDataV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return series of elements that render a "wedge", which is the same as the arc above except that it's connected to the circle center and filled
     * @param center: center of the circle on which the arc sits
     * @param start: coordinate to start drawing the arc
     * @param end: coordinate to finish drawing the arc
     * @param radius: width and height of the ellipse to draw the arc along (i.e. [width, height])
     * @param rotation: angle in degrees to rotate ellipse about its center
     * @param largeArc: 0 to draw shorter of 2 arcs, 1 to draw longer
     * @param arcSweep: 0 to rotate CCW, 1 to rotate CW
     * @returns: Elements that can be passed to Path shape spec to render an SVG arc
     */
    wedge: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, center: ad.Pt2, start: ad.Pt2, end: ad.Pt2, radius: ad.Pt2, rotation: ad.Num, largeArc: ad.Num, arcSweep: ad.Num) => MayWarn<PathDataV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Find the point that is located at dist r along a line between p1 and p2.
     * @param p1: start point of line segment
     * @param p2: endpoint of line segment
     * @param r: distance from p1 to travel along the line
     * @returns: vector representation of the point of intersection
     */
    ptOnLine: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, p1: ad.Num[], p2: ad.Num[], r: ad.Num) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return 0 if direction of rotation is CCW, 1 if direction of rotation is CW.
     * @param x1, y1: x, y coordinates of the circle/ellipse that the arc is drawn on
     * @param start: start point of the arc
     * @param end: end point of the arc
     * @returns: 0 or 1 depending on CCW or CW rotation
     */
    arcSweepFlag: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, [x1, y1]: ad.Num[], start: ad.Pt2, end: ad.Pt2) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the unsigned angle between vectors `u, v`, in radians.
     * Assumes that both u and v have nonzero magnitude.
     * The returned value will be in the range [0,pi].
     */
    angleBetween: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, u: ad.Num[], v: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the signed angle from vector `u` to vector `v`, in radians.
     * Assumes that both u and v are 2D vectors and have nonzero magnitude.
     * The returned value will be in the range [-pi,pi].
     */
    angleFrom: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, u: ad.Num[], v: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the 2D cross product of `u` and `v`, equal to the determinant of the 2x2 matrix [u v]
     */
    cross2D: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, u: ad.Num[], v: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the 3D cross product of `u` and `v`.
     */
    cross: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, u: ad.Num[], v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the intersection of a line passing through
     * `a0` and `a1` with a line passing through `b0` and `b1`
     */
    lineLineIntersection: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, a0: ad.Num[], a1: ad.Num[], b0: ad.Num[], b1: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return a point located at the midpoint between pts `start` and `end`
     */
    midpoint: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, start: ad.Num[], end: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return a point located at the midpoint of a line `s1` but offset by `padding` in its normal direction (for labeling).
     */
    midpointOffset: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, s1: Line<ad.Num>, padding: ad.Num) => MayWarn<TupV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    chevron: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, s1: Line<ad.Num>, padding: ad.Num) => MayWarn<PtListV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return a point located at `padding` of a line `s1` offset by `padding` in its normal direction (for making right angle markers).
     */
    innerPointOffset: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, pt1: ad.Num[], pt2: ad.Num[], pt3: ad.Num[], padding: ad.Num) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Create equally spaced tick marks centered at the midpoint of a line
     * @param pt1: starting point of a line
     * @param pt2: endping point of a line
     * @param spacing: space in px between each tick
     * @param numTicks: number of tick marks to create
     * @param tickLength: 1/2 length of each tick
     */
    ticksOnLine: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, pt1: ad.Num[], pt2: ad.Num[], spacing: ad.Num, numTicks: ad.Num, tickLength: ad.Num) => MayWarn<PathDataV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Given two orthogonal segments that intersect at `intersection`, and a size `len`
     * return a path comprised of three points that describe a perpendicular mark at the angle where the segments intersect.
     */
    orientedSquare: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, s1: Line<ad.Num>, s2: Line<ad.Num>, intersection: ad.Pt2, len: ad.Num) => MayWarn<PathDataV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Given three lines `l1, l2, l3` that already form a triangle, return a path that describes the triangle (which can then be filled, etc.).
     */
    triangle: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
        }[];
        body: (_context: Context, l1: Line<ad.Num>, l2: Line<ad.Num>, l3: Line<ad.Num>) => MayWarn<PathDataV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the average of floats `x` and `y`.
     */
    average2: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, x: ad.Num, y: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the average of the floats in the list `xs`.
     */
    average: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, xs: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the normalized version of vector `v`.
     */
    unit: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return a uniform random value between minVal and maxValue.
     */
    random: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: ({ makeInput }: Context, minVal: ad.Num, maxVal: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return a uniform random value between 0 and 1
     */
    unitRandom: {
        name: string;
        description: string;
        params: never[];
        body: ({ makeInput }: Context) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return a random value sampled from the uniform distribution on the unit disk.
     */
    diskRandom: {
        name: string;
        description: string;
        params: never[];
        body: ({ makeInput }: Context) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return a random value sampled from the uniform distribution on the unit circle.
     */
    circleRandom: {
        name: string;
        description: string;
        params: never[];
        body: ({ makeInput }: Context) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return a random value sampled from the uniform distribution on the unit sphere.
     */
    sphereRandom: {
        name: string;
        description: string;
        params: never[];
        body: ({ makeInput }: Context) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return a random value sampled from a normal distribution with mean 0 and standard deviation 1.
     */
    normalRandom: {
        name: string;
        description: string;
        params: never[];
        body: ({ makeInput }: Context) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return a random point sampled from the uniform distribution on a triangle with vertices a, b, c.
     */
    triangleRandom: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: ({ makeInput }: Context, a: ad.Num[], b: ad.Num[], c: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Sample a random color once, with opacity `alpha` and colorType `colorType` (`"rgb"` or `"hsv"`).
     */
    sampleColor: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: ({ makeInput }: Context, alpha: ad.Num, colorType: "rgb" | "hsv") => MayWarn<ColorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Set the opacity of a color `color` to `frac`.
     */
    setOpacity: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, color: Color<ad.Num>, frac: ad.Num) => MayWarn<ColorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Multiply a matrix `m` and a vector `v` (where `v` is implicitly treated as a column vector).
     */
    mul: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, m: ad.Num[][], v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the barycenter of the triangle with vertices `a`, `b`, `c`.
     */
    barycenter: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, a: ad.Num[], b: ad.Num[], c: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the circumcenter of the triangle with vertices `p`, `q`, `r`.
     */
    circumcenter: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, p: ad.Num[], q: ad.Num[], r: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the circumradius of the triangle with vertices `p`, `q`, `r`.
     */
    circumradius: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, p: ad.Num[], q: ad.Num[], r: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the incenter of the triangle with vertices `p`, `q`, `r`.
     */
    incenter: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, p: ad.Num[], q: ad.Num[], r: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the inradius of the triangle with vertices `p`, `q`, `r`.
     */
    inradius: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, p: ad.Num[], q: ad.Num[], r: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the square of the number `x`.
     */
    sqr: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the square root of the number `x`. (NOTE: if `x < 0`, you may get `NaN`s)
     */
    sqrt: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the max of the numbers `x`, `y`.
     */
    max: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, x: ad.Num, y: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the min of the numbers `x`, `y`.
     */
    min: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, x: ad.Num, y: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the absolute value of the number `x`.
     */
    abs: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, x: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Convert the angle `theta` from degrees to radians.
     */
    toRadians: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, theta: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Convert the angle `theta` from radians to degrees.
     */
    toDegrees: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, theta: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the Euclidean norm of the vector `v`.
     */
    norm: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, v: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the Euclidean norm squared of the vector `v`.
     */
    normsq: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, v: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the Euclidean distance between the vectors `v` and `w`.
     */
    vdist: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, v: ad.Num[], w: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    vmul: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, s: ad.Num, v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the Euclidean distance squared between the vectors `v` and `w`.
     */
    vdistsq: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, v: ad.Num[], w: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Return the angle made by the vector `v` with the positive x-axis.
     */
    angleOf: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, v: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Base e of the natural logarithm.
     */
    MathE: {
        name: string;
        description: string;
        params: never[];
        body: (_context: Context) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Ratio of the circumference of a circle to its diameter.
     */
    MathPI: {
        name: string;
        description: string;
        params: never[];
        body: (_context: Context) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Rotate a 2D vector `v` by 90 degrees counterclockwise.
     */
    rot90: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Rotate a 2D vector `v` by theta degrees counterclockwise.
     */
    rotateBy: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, v: ad.Num[], theta: ad.Num) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    signedDistance: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").UnionT;
            description: string;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, shape: Shape<ad.Num>, pt: ad.Pt2) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    signedDistanceRect: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, rect: ad.Pt2[], pt: ad.Pt2) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    signedDistanceCircle: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, c: ad.Pt2, r: ad.Num, pt: ad.Pt2) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    signedDistancePolygon: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, pts: ad.Pt2[], pt: ad.Pt2) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    signedDistanceEllipse: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, c: ad.Pt2, rx: ad.Num, ry: ad.Num, pt: ad.Pt2) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    signedDistanceLine: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, start: ad.Pt2, end: ad.Pt2, pt: ad.Pt2) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    signedDistancePolyline: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, pts: ad.Pt2[], pt: ad.Pt2) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    signedDistanceGroup: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (_context: Context, shapes: Shape<ad.Num>[], pt: ad.Pt2) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Construct a unit vector u in the direction of the
     * given angle theta (in radians).
     */
    unitVector: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, theta: ad.Num) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersect: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").UnionT;
            description: string;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, S: Circle<ad.Num> | Rectlike<ad.Num> | Line<ad.Num> | Polyline<ad.Num> | Polygon<ad.Num> | Ellipse<ad.Num> | Group<ad.Num>, p: ad.Num[], v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectDistance: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").UnionT;
            description: string;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, S: Circle<ad.Num> | Rectlike<ad.Num> | Line<ad.Num> | Polyline<ad.Num> | Polygon<ad.Num> | Ellipse<ad.Num> | Group<ad.Num>, p: ad.Num[], v: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectCircle: {
        name: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, c: ad.Num[], r: ad.Num, p: ad.Num[], v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectCircleDistance: {
        name: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, c: ad.Num[], r: ad.Num, p: ad.Num[], v: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectEllipse: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, c: ad.Num[], rx: ad.Num, ry: ad.Num, p: ad.Num[], v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectEllipseDistance: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, c: ad.Num[], rx: ad.Num, ry: ad.Num, p: ad.Num[], v: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectLine: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, start: ad.Num[], end: ad.Num[], p: ad.Num[], v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectLineDistance: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, start: ad.Num[], end: ad.Num[], p: ad.Num[], v: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectRect: {
        name: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, rect: ad.Pt2[], p: ad.Num[], v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectRectDistance: {
        name: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, rect: ad.Pt2[], p: ad.Num[], v: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectPoly: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, pts: ad.Pt2[], closed: boolean, p: ad.Num[], v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectPolyDistance: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, pts: ad.Pt2[], closed: boolean, p: ad.Num[], v: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectGroup: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, shapes: Shape<ad.Num>[], p: ad.Num[], v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectGroupDistance: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, shapes: Shape<ad.Num>[], p: ad.Num[], v: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectNormal: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").UnionT;
            description: string;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, S: Circle<ad.Num> | Rectlike<ad.Num> | Line<ad.Num> | Polyline<ad.Num> | Polygon<ad.Num> | Ellipse<ad.Num> | Group<ad.Num>, p: ad.Num[], v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectNormalCircle: {
        name: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, c: ad.Num[], r: ad.Num, p: ad.Num[], v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectNormalEllipse: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, c: ad.Num[], rx: ad.Num, ry: ad.Num, p: ad.Num[], v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectNormalLine: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, start: ad.Num[], end: ad.Num[], p: ad.Num[], v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectNormalRect: {
        name: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, rect: ad.Pt2[], p: ad.Num[], v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectNormalPoly: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, pts: ad.Pt2[], closed: boolean, p: ad.Num[], v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rayIntersectNormalGroup: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, shapes: Shape<ad.Num>[], p: ad.Num[], v: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    closestPoint: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").UnionT;
            description: string;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, shape: Shape<ad.Num>, p: ad.Pt2) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    closestPointCircle: {
        name: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, c: ad.Pt2, r: ad.Num, pt: ad.Pt2) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    closestPointRect: {
        name: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, rect: ad.Pt2[], pt: ad.Pt2) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    closestPointLine: {
        name: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, start: ad.Pt2, end: ad.Pt2, pt: ad.Pt2) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    closestPointEllipse: {
        name: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, c: ad.Pt2, rx: ad.Num, ry: ad.Num, pt: ad.Pt2) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    closestPointPoly: {
        name: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, pts: ad.Pt2[], closed: boolean, pt: ad.Pt2) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    closestPointGroup: {
        name: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, shapes: Shape<ad.Num>[], pt: ad.Pt2) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    closestSilhouettePoint: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").UnionT;
            description: string;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, s: Circle<ad.Num> | Rectlike<ad.Num> | Line<ad.Num> | Polyline<ad.Num> | Polygon<ad.Num> | Ellipse<ad.Num> | Group<ad.Num>, p: ad.Num[]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    closestSilhouettePointCircle: {
        name: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, c: ad.Pt2, r: ad.Num, p: ad.Pt2) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    closestSilhouettePointEllipse: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, c: ad.Pt2, rx: ad.Num, ry: ad.Num, p: ad.Pt2) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    closestSilhouettePointLine: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, start: ad.Pt2, end: ad.Pt2, p: ad.Pt2) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    closestSilhouettePointRect: {
        name: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, rect: ad.Pt2[], p: ad.Pt2) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    closestSilhouettePointPolyline: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, points: ad.Pt2[], p: ad.Pt2) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    closestSilhouettePointPolygon: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, points: ad.Pt2[], p: ad.Pt2) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    closestSilhouettePointGroup: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
            description?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, shapes: Shape<ad.Num>[], p: ad.Pt2) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    closestSilhouetteDistance: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").UnionT;
            description: string;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (_context: Context, s: Circle<ad.Num> | Rectlike<ad.Num> | Line<ad.Num> | Polyline<ad.Num> | Polygon<ad.Num> | Ellipse<ad.Num> | Group<ad.Num>, p: ad.Num[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rectLineDist: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, bottomLeft: ad.Pt2, topRight: ad.Pt2, start: ad.Pt2, end: ad.Pt2) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    shapeDistance: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
        }[];
        body: (_context: Context, s1: Shape<ad.Num>, s2: Shape<ad.Num>) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    shapeDistanceCircles: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, c1: ad.Pt2, r1: ad.Num, c2: ad.Pt2, r2: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    shapeDistanceRects: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, rect1: ad.Pt2[], rect2: ad.Pt2[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    shapeDistanceRectLine: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, rect: ad.Pt2[], start: ad.Pt2, end: ad.Pt2) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    shapeDistanceRectlikePolyline: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, rect: ad.Pt2[], points: ad.Num[][]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    shapeDistancePolys: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, pts1: ad.Pt2[], pts2: ad.Pt2[]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    shapeDistanceRectCircle: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, rect: ad.Pt2[], c: ad.Pt2, r: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    shapeDistancePolyEllipse: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, pts: ad.Pt2[], c: ad.Pt2, rx: ad.Num, ry: ad.Num) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    shapeDistanceCircleLine: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, c: ad.Pt2, r: ad.Num, start: ad.Pt2, end: ad.Pt2) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    shapeDistanceLines: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, start1: ad.Pt2, end1: ad.Pt2, start2: ad.Pt2, end2: ad.Pt2) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Returns the signed area enclosed by a polygonal chain given its nodes
     */
    signedArea: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][], closed: boolean) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Returns the turning number of polygonal chain given its nodes
     */
    turningNumber: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][], closed: boolean) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Returns the total length of polygonal chain given its nodes
     */
    perimeter: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][], closed: boolean) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Returns the isoperimetric ratio (perimeter squared divided by enclosed area)
     */
    isoperimetricRatio: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][], closed: boolean) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Returns integral of curvature squared along the curve
     */
    elasticEnergy: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][], closed: boolean) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Returns integral of curvature along the curve
     */
    totalCurvature: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][], closed: boolean, signed?: boolean) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Returns the sum of all line segment lengths raised to `k`
     */
    lengthK: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][], closed: boolean, k: number) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Returns the maximum value of curvature along the curve
     */
    maxCurvature: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][], closed: boolean) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Returns integral of curvature raised to `p` along the curve
     */
    pElasticEnergy: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][], closed: boolean, p: number) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Returns integral of curvature derivative raised to `p` along the curve
     */
    inflectionEnergy: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][], closed: boolean, p: number) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Returns list of `n` tangent vectors given a list of `n` points.
     */
    tangentVectors: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][], closed: boolean) => MayWarn<LListV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Returns list of `n` normal vectors given a list of `n` points.
     * If points are 2D, it calculates a normal vector as a perpendicular vector to the tangent.
     * Otherwise, it calculates the principal normal vector.
     */
    normalVectors: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][], closed: boolean) => MayWarn<LListV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Returns list of `n` binormal vectors given a list of `n` points.
     */
    binormalVectors: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][], closed: boolean) => MayWarn<LListV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Returns evolute curve from a list of `n` points.
     */
    evoluteCurve: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][], closed: boolean) => MayWarn<LListV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Returns an offset version of the input curve.
     */
    offsetCurve: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][], closed: boolean, magnitude: ad.Num) => MayWarn<LListV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Returns list of `n` curvature values given a list of `n` points.
     */
    curvatures: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][], closed: boolean) => MayWarn<ListV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    /**
     * Returns center of mass for a 2D point cloud
     */
    centerOfMass: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: [ad.Num, ad.Num][]) => MayWarn<VectorV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    noClip: {
        name: string;
        description: string;
        params: never[];
        body: (_context: Context) => MayWarn<ClipDataV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    clip: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ShapeT;
        }[];
        body: (_context: Context, shape: Shape<ad.Num>) => MayWarn<ClipDataV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    bboxPts: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
        }[];
        body: (_context: Context, s: Shape<ad.Num>) => MayWarn<PtListV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    tsneEnergy: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (_context: Context, points: ad.Num[][], projectedPoints: ad.Num[][]) => MayWarn<FloatV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
    rectPts: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").UnionT;
        }[];
        body: (_context: Context, s: Rectlike<ad.Num>) => MayWarn<PtListV<ad.Num>>;
        returns: import("../types/types.js").ValueT;
    };
};
export declare const msign: (x: ad.Num) => ad.Num;
export declare const signedDistanceRect: (rect: ad.Pt2[], pt: ad.Pt2) => ad.Num;
export declare const signedDistanceCircle: (c: ad.Pt2, r: ad.Num, pt: ad.Pt2) => ad.Num;
export declare const signedDistancePolygon: (pts: ad.Pt2[], pt: ad.Pt2) => ad.Num;
export declare const signedDistanceEllipse: (center: ad.Pt2, radiusx: ad.Num, radiusy: ad.Num, pInput: ad.Pt2) => ad.Num;
export declare const signedDistanceLine: (start: ad.Pt2, end: ad.Pt2, pt: ad.Pt2) => ad.Num;
export declare const signedDistancePolyline: (pts: ad.Pt2[], pt: ad.Pt2) => ad.Num;
export declare const signedDistanceGroup: (ss: Shape<ad.Num>[], pt: ad.Pt2) => ad.Num;
export declare const safeRI: (hit: ad.Num[][], p: ad.Num[]) => ad.Num[];
export declare const safeRIN: (hit: ad.Num[][], p: ad.Num[]) => ad.Num[];
export declare const distRI: (hit: ad.Num[][], p: ad.Num[]) => ad.Num;
export declare const rawRayIntersect: (s: Circle<ad.Num> | Rectlike<ad.Num> | Line<ad.Num> | Polyline<ad.Num> | Polygon<ad.Num> | Ellipse<ad.Num> | Path<ad.Num> | Group<ad.Num>, p: ad.Num[], v: ad.Num[]) => ad.Num[][];
export declare const rawRayIntersectCircle: (c: ad.Num[], r: ad.Num, p: ad.Num[], v: ad.Num[]) => ad.Num[][];
export declare const rawRayIntersectEllipse: (center: ad.Num[], rx: ad.Num, ry: ad.Num, p0: ad.Num[], v0: ad.Num[]) => ad.Num[][];
export declare const rawRayIntersectLine: (start: ad.Num[], end: ad.Num[], p: ad.Num[], v: ad.Num[]) => ad.Num[][];
export declare const rawRayIntersectRect: ([tr, tl, bl, br]: ad.Num[][], p: ad.Num[], v: ad.Num[]) => ad.Num[][];
export declare const rawRayIntersectPoly: (points: ad.Num[][], closed: boolean, p: ad.Num[], v: ad.Num[]) => ad.Num[][];
export declare const rawRayIntersectGroup: (shapes: Shape<ad.Num>[], p: ad.Num[], v: ad.Num[]) => ad.Num[][];
export declare const closestPoint: (s: Circle<ad.Num> | Rectlike<ad.Num> | Line<ad.Num> | Polyline<ad.Num> | Polygon<ad.Num> | Ellipse<ad.Num> | Path<ad.Num> | Group<ad.Num>, p: ad.Num[]) => ad.Num[];
export declare const closestPointCircle: (c: ad.Num[], r: ad.Num, p: ad.Num[]) => ad.Num[];
export declare const closestPointLine: (start: ad.Num[], end: ad.Num[], p: ad.Num[]) => ad.Num[];
export declare const closestPointPoly: (points: ad.Num[][], closed: boolean, p: ad.Num[]) => ad.Num[];
export declare const closestPointRect: (rect: ad.Num[][], p: ad.Num[]) => ad.Num[];
export declare const closestPointEllipse: (c: ad.Num[], rx: ad.Num, ry: ad.Num, p: ad.Num[]) => ad.Num[];
export declare const closestPointGroup: (shapes: Shape<ad.Num>[], p: ad.Num[]) => ad.Num[];
export declare const safeCSP: (q: ad.Num[], p: ad.Num[]) => ad.Num[];
export declare const rawClosestSilhouettePoint: (s: Circle<ad.Num> | Rectlike<ad.Num> | Line<ad.Num> | Polyline<ad.Num> | Polygon<ad.Num> | Ellipse<ad.Num> | Path<ad.Num> | Group<ad.Num>, p: ad.Num[]) => ad.Num[];
export declare const rawClosestSilhouettePointCircle: (c: ad.Num[], r: ad.Num, p: ad.Num[]) => ad.Num[];
export declare const rawClosestSilhouettePointEllipse: (c: ad.Num[], rx: ad.Num, ry: ad.Num, p: ad.Num[]) => ad.Num[];
export declare const rawClosestSilhouettePointLine: (start: ad.Num[], end: ad.Num[], p: ad.Num[]) => ad.Num[];
export declare const rawClosestSilhouettePointRect: ([tr, tl, bl, br]: ad.Num[][], p: ad.Num[]) => ad.Num[];
export declare const rawClosestSilhouettePointPolyline: (pts: ad.Num[][], p: ad.Num[]) => ad.Num[];
export declare const rawClosestSilhouettePointPolygon: (pts: ad.Num[][], p: ad.Num[]) => ad.Num[];
export declare const rawClosestSilhouettePointGroup: (shapes: Shape<ad.Num>[], p: ad.Num[]) => ad.Num[];
/**
 *  Return the signed distance to an axis-aligned rectangle:
 *  float sdBox( in vec2 p, in vec2 b )
 *  {
 *    vec2 d = abs(p)-b;
 *    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
 *  }
 */
export declare const sdfRect: (center: ad.Num[], width: ad.Num, height: ad.Num, p: ad.Num[]) => ad.Num;
//# sourceMappingURL=Functions.d.ts.map