import { EPS_DENOM, ops } from "../engine/Autodiff.js";
import { absVal, add, div, ifCond, lte, max, mul, neg, squared, sub, } from "../engine/AutodiffFunctions.js";
import { msign } from "./Functions.js";
import { outwardUnitNormal } from "./Queries.js";
import { toPt } from "./Utils.js";
/**
 * Evaluate the implicit function for an ellipse at point with coordinates `x` and `y`.
 * @param ei Implicit ellipse parameters.
 * @param x X-coordinate.
 * @param y Y-coordinate.
 */
export const implicitEllipseFunc = (ei, x, y) => {
    return sub(add(mul(ei.a, squared(sub(x, ei.x))), mul(ei.b, squared(sub(y, ei.y)))), ei.c);
};
/**
 * Evaluate the implicit function for an intersection of 2 ellipses at point with coordinates `x` and `y`.
 * @param ei1 First implicit ellipse parameters.
 * @param ei2 Second implicit ellipse parameters.
 * @param x X-coordinate.
 * @param y Y-coordinate.
 */
export const implicitIntersectionOfEllipsesFunc = (ei1, ei2, x, y) => {
    return max(implicitEllipseFunc(ei1, x, y), implicitEllipseFunc(ei2, x, y));
};
/**
 * Evaluate the implicit function for an half-plane at point with coordinates `x` and `y`.
 * @param hpi Implicit half-plane parameters.
 * @param x X-coordinate.
 * @param y Y-coordinate.
 */
export const implicitHalfPlaneFunc = (hpi, x, y) => {
    return sub(add(mul(hpi.a, x), mul(hpi.b, y)), hpi.c);
};
/**
 * Return implicit half-plane parameters given a line and a point inside the half-plane.
 * @param lineSegment Two points defining the line segment.
 * @param insidePoint Any point inside of the half-plane.
 * @param padding Padding around the Half-plane.
 */
export const halfPlaneToImplicit = (lineSegment, insidePoint, padding) => {
    const normal = outwardUnitNormal(lineSegment, insidePoint);
    return {
        a: normal[0],
        b: normal[1],
        c: sub(ops.vdot(normal, lineSegment[0]), padding),
    };
};
/**
 * Return implicit ellipse parameters from an explicit representation.
 * @param e Explicit ellipse shape.
 * @param padding Padding added to the ellipse.
 * Note: this is an approximation of Minkowski sum of ellipse and circle.
 * But the difference should be negligable for small `padding` and/or eccentricity.
 * @param factor Multiplication factor for the implicit function (the function is not uniquely given).
 */
export const ellipseToImplicit = (e, padding, factor = 1) => {
    return absEllipseToImplicit(toPt(e.center.contents), e.rx.contents, e.ry.contents, padding, factor);
};
export const absEllipseToImplicit = (c, rx, ry, padding, factor = 1) => {
    const rxp = add(rx, padding);
    const ryp = add(ry, padding);
    return {
        a: mul(factor, div(ryp, rxp)),
        b: mul(factor, div(rxp, ryp)),
        c: mul(factor, mul(rxp, ryp)),
        x: c[0],
        y: c[1],
    };
};
/**
 * Return implicit ellipse parameters from an explicit circle.
 * @param circle Explicit circle shape.
 */
export const circleToImplicitEllipse = (circle, padding, factor = 1) => {
    return absCircleToImplicitEllipse(toPt(circle.center.contents), circle.r.contents, padding, factor);
};
export const absCircleToImplicitEllipse = (c, r, padding, factor = 1) => {
    return {
        a: factor,
        b: factor,
        c: mul(factor, squared(add(r, padding))),
        x: c[0],
        y: c[1],
    };
};
// Constant coefficient from the ellipse-ellipse polynomial
const ellipsePolynomialAlpha0 = (a, b) => {
    return mul(mul(squared(a.a), squared(a.b)), add(sub(a.c, b.c), add(mul(b.a, squared(sub(b.x, a.x))), mul(b.b, squared(sub(b.y, a.y))))));
};
// Linear coefficient from the ellipse-ellipse polynomial
const ellipsePolynomialAlpha1 = (a, b) => {
    const coef = mul(2, mul(a.a, a.b));
    return mul(coef, add(mul(sub(a.c, b.c), sub(add(mul(a.a, b.b), mul(a.b, b.a)), coef)), add(mul(mul(a.a, b.a), mul(squared(sub(b.x, a.x)), sub(b.b, mul(2, a.b)))), mul(mul(a.b, b.b), mul(squared(sub(b.y, a.y)), sub(b.a, mul(2, a.a)))))));
};
// Quadratic coefficient from the ellipse-ellipse polynomial
const ellipsePolynomialAlpha2 = (a, b) => {
    const coeff1 = add(add(mul(squared(a.a), squared(sub(b.b, a.b))), mul(squared(a.b), squared(sub(b.a, a.a)))), mul(mul(4, mul(a.a, a.b)), mul(sub(b.b, a.b), sub(b.a, a.a))));
    const coeff2 = sub(mul(squared(a.b), sub(mul(6, a.a), b.a)), mul(mul(a.a, b.b), sub(mul(6, a.b), b.b)));
    const coeff3 = sub(mul(squared(a.a), sub(mul(6, a.b), b.b)), mul(mul(a.b, b.a), sub(mul(6, a.a), b.a)));
    return add(mul(coeff1, sub(a.c, b.c)), add(mul(mul(coeff2, mul(a.a, b.a)), squared(sub(b.x, a.x))), mul(mul(coeff3, mul(a.b, b.b)), squared(sub(b.y, a.y)))));
};
// Cubic coefficient from the ellipse-ellipse polynomial
const ellipsePolynomialAlpha3 = (a, b) => {
    const factor = mul(2, sub(mul(2, mul(a.a, a.b)), add(mul(a.b, b.a), mul(a.a, b.b))));
    return mul(factor, add(mul(mul(sub(b.a, a.a), sub(b.b, a.b)), sub(b.c, a.c)), add(mul(mul(a.a, b.a), mul(squared(sub(b.x, a.x)), sub(b.b, a.b))), mul(mul(a.b, b.b), mul(squared(sub(b.y, a.y)), sub(b.a, a.a))))));
};
// Quartic coefficient from the ellipse-ellipse polynomial
const ellipsePolynomialAlpha4 = (a, b) => {
    return neg(add(mul(mul(squared(sub(b.a, a.a)), squared(sub(b.b, a.b))), sub(b.c, a.c)), add(mul(mul(mul(a.a, b.a), squared(sub(b.x, a.x))), mul(sub(b.a, a.a), squared(sub(b.b, a.b)))), mul(mul(mul(a.b, b.b), squared(sub(b.y, a.y))), mul(squared(sub(b.a, a.a)), sub(b.b, a.b))))));
};
// Coefficients of the ellipse-ellipse polynomial
// (ordered from the lowest by their corresponding deggree)
const ellipsePolynomialParams = (a, b) => {
    return [
        ellipsePolynomialAlpha0(a, b),
        ellipsePolynomialAlpha1(a, b),
        ellipsePolynomialAlpha2(a, b),
        ellipsePolynomialAlpha3(a, b),
        ellipsePolynomialAlpha4(a, b),
    ];
};
// Return monic polynomial coefficients
// (the highest order coefficient is omitted and assumed to be 1)
export const ellipsePolynomial = (a, b) => {
    const params = ellipsePolynomialParams(a, b);
    // Prevent division by zero (note that `params[4]` being close 0
    // may still cause instability in the root solver later)
    params[4] = ifCond(lte(absVal(params[4]), 1e-14), mul(msign(params[4]), EPS_DENOM), params[4]);
    return Array.from(Array(4).keys()).map((i) => div(params[i], params[4]));
};
//# sourceMappingURL=ImplicitShapes.js.map