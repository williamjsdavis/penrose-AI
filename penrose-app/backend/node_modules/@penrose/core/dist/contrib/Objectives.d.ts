import { Line } from "../shapes/Line.js";
import { Shape } from "../shapes/Shapes.js";
import * as ad from "../types/ad.js";
import { Linelike, Rectlike } from "./Utils.js";
export declare const objDictSimple: {
    /**
     * Encourage the input value to be close to negative infinity
     */
    minimal: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (x: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage the input value to be close to infinity
     */
    maximal: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (x: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage the inputs to have the same value: `(x - y)^2`
     */
    equal: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (x: ad.Num, y: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    nearVec: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (v1: ad.Num[], v2: ad.Num[], offset: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage x to be greater than or equal to y: `max(0,y - x)^2`
     */
    greaterThan: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (x: ad.Num, y: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage x to be less than or equal to y: `max(0,x - y)^2`
     */
    lessThan: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (x: ad.Num, y: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Repel point `a` from another scalar `b` with weight `weight`.
     */
    repelPt: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (weight: ad.Num, a: ad.Num[], b: ad.Num[]) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Repel scalar `c` from another scalar `d`.
     */
    repelScalar: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (c: ad.Num, d: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
};
export declare const objDictGeneral: {
    inDirection: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (p: ad.Pt2, pRef: ad.Pt2, direction: ad.Pt2, offset: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage the center of `sTop` to be above the center of `sBottom`.
     * Only works for shapes with property `center`.
     */
    below: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default: number;
        })[];
        body: (bottom: Shape<ad.Num>, top: Shape<ad.Num>, offset?: any) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage the center of `sBottom` to be below the center of `sTop`.
     */
    above: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default: number;
        })[];
        body: (top: Shape<ad.Num>, bottom: Shape<ad.Num>, offset?: any) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage the center of `sLeft` to be leftwards to the center of `sRight`.
     */
    leftwards: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default: number;
        })[];
        body: (left: Shape<ad.Num>, right: Shape<ad.Num>, offset?: any) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage the center of `sRight` to be rightwards to the center of `sLeft`.
     */
    rightwards: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default: number;
        })[];
        body: (right: Shape<ad.Num>, left: Shape<ad.Num>, offset?: any) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage shape `s1` to have the same center position as shape `s2`.
     */
    sameCenter: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
        }[];
        body: (s1: Shape<ad.Num>, s2: Shape<ad.Num>) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Try to repel shapes `s1` and `s2` with some weight.
     */
    notTooClose: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default: number;
        })[];
        body: (s1: Shape<ad.Num>, s2: Shape<ad.Num>, weight?: any) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Try to place shape `s1` near shape `s2` (putting their centers at the same place).
     */
    near: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default: number;
        })[];
        body: (s1: Shape<ad.Num>, s2: Shape<ad.Num>, offset?: any) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Try to place shape `s1` near a location `(x, y)`.
     */
    nearPt: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (s1: Shape<ad.Num>, x: ad.Num, y: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Repel the angle between the p1-p0 and p1-p2 away from 0 and 180 degrees.
     * NOTE: angles more than `range` degrees from 0 or 180 deg are considered satisfied.
     */
    nonDegenerateAngle: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default: number;
        })[];
        body: (s0: Shape<ad.Num>, s1: Shape<ad.Num>, s2: Shape<ad.Num>, strength?: any, range?: any) => import("../types/functions.js").MayWarn<ad.Num>;
    };
};
export declare const objDictSpecific: {
    centerLabelAbove: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
        } | {
            name: string;
            type: import("../types/types.js").UnionT;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
        })[];
        body: (s1: Line<ad.Num>, s2: Rectlike<ad.Num>, w: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Try to center a label `s2` with respect to some shape `s1`.
     */
    centerLabel: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").UnionT;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (s1: Rectlike<ad.Num> | Linelike<ad.Num>, s2: Rectlike<ad.Num>, w: number, padding?: any) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * try to make distance between a point and a segment `s1` = padding.
     */
    pointLineDist: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
        } | {
            name: string;
            type: import("../types/types.js").ShapeT;
        })[];
        body: (point: ad.Num[], s1: Line<ad.Num>, padding: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * The shape should be regular (equiangular and equilateral)
     */
    isRegular: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (points: ad.Num[][], closed: boolean) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * The shape should be equilateral
     */
    isEquilateral: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (points: ad.Num[][], closed: boolean) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * The shape should be equiangular
     */
    isEquiangular: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (points: ad.Num[][], closed: boolean) => import("../types/functions.js").MayWarn<ad.Num>;
    };
};
export declare const objDict: {
    centerLabelAbove: {
        name: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
        } | {
            name: string;
            type: import("../types/types.js").UnionT;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
        })[];
        body: (s1: Line<ad.Num>, s2: Rectlike<ad.Num>, w: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Try to center a label `s2` with respect to some shape `s1`.
     */
    centerLabel: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").UnionT;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (s1: Rectlike<ad.Num> | Linelike<ad.Num>, s2: Rectlike<ad.Num>, w: number, padding?: any) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * try to make distance between a point and a segment `s1` = padding.
     */
    pointLineDist: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ValueT;
        } | {
            name: string;
            type: import("../types/types.js").ShapeT;
        })[];
        body: (point: ad.Num[], s1: Line<ad.Num>, padding: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * The shape should be regular (equiangular and equilateral)
     */
    isRegular: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (points: ad.Num[][], closed: boolean) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * The shape should be equilateral
     */
    isEquilateral: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (points: ad.Num[][], closed: boolean) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * The shape should be equiangular
     */
    isEquiangular: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (points: ad.Num[][], closed: boolean) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    inDirection: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (p: ad.Pt2, pRef: ad.Pt2, direction: ad.Pt2, offset: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage the center of `sTop` to be above the center of `sBottom`.
     * Only works for shapes with property `center`.
     */
    below: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default: number;
        })[];
        body: (bottom: Shape<ad.Num>, top: Shape<ad.Num>, offset?: any) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage the center of `sBottom` to be below the center of `sTop`.
     */
    above: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default: number;
        })[];
        body: (top: Shape<ad.Num>, bottom: Shape<ad.Num>, offset?: any) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage the center of `sLeft` to be leftwards to the center of `sRight`.
     */
    leftwards: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default: number;
        })[];
        body: (left: Shape<ad.Num>, right: Shape<ad.Num>, offset?: any) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage the center of `sRight` to be rightwards to the center of `sLeft`.
     */
    rightwards: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default: number;
        })[];
        body: (right: Shape<ad.Num>, left: Shape<ad.Num>, offset?: any) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage shape `s1` to have the same center position as shape `s2`.
     */
    sameCenter: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
        }[];
        body: (s1: Shape<ad.Num>, s2: Shape<ad.Num>) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Try to repel shapes `s1` and `s2` with some weight.
     */
    notTooClose: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default: number;
        })[];
        body: (s1: Shape<ad.Num>, s2: Shape<ad.Num>, weight?: any) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Try to place shape `s1` near shape `s2` (putting their centers at the same place).
     */
    near: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default: number;
        })[];
        body: (s1: Shape<ad.Num>, s2: Shape<ad.Num>, offset?: any) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Try to place shape `s1` near a location `(x, y)`.
     */
    nearPt: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        })[];
        body: (s1: Shape<ad.Num>, x: ad.Num, y: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Repel the angle between the p1-p0 and p1-p2 away from 0 and 180 degrees.
     * NOTE: angles more than `range` degrees from 0 or 180 deg are considered satisfied.
     */
    nonDegenerateAngle: {
        name: string;
        description: string;
        params: ({
            name: string;
            type: import("../types/types.js").ShapeT;
            description: string;
            default?: undefined;
        } | {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
            default: number;
        })[];
        body: (s0: Shape<ad.Num>, s1: Shape<ad.Num>, s2: Shape<ad.Num>, strength?: any, range?: any) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage the input value to be close to negative infinity
     */
    minimal: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (x: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage the input value to be close to infinity
     */
    maximal: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (x: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage the inputs to have the same value: `(x - y)^2`
     */
    equal: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (x: ad.Num, y: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    nearVec: {
        name: string;
        description: string;
        params: {
            name: string;
            type: import("../types/types.js").ValueT;
            description: string;
        }[];
        body: (v1: ad.Num[], v2: ad.Num[], offset: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage x to be greater than or equal to y: `max(0,y - x)^2`
     */
    greaterThan: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (x: ad.Num, y: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Encourage x to be less than or equal to y: `max(0,x - y)^2`
     */
    lessThan: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (x: ad.Num, y: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Repel point `a` from another scalar `b` with weight `weight`.
     */
    repelPt: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (weight: ad.Num, a: ad.Num[], b: ad.Num[]) => import("../types/functions.js").MayWarn<ad.Num>;
    };
    /**
     * Repel scalar `c` from another scalar `d`.
     */
    repelScalar: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (c: ad.Num, d: ad.Num) => import("../types/functions.js").MayWarn<ad.Num>;
    };
};
//# sourceMappingURL=Objectives.d.ts.map