import * as BBox from "../engine/BBox.js";
import { Equation } from "../shapes/Equation.js";
import { Image } from "../shapes/Image.js";
import { Line } from "../shapes/Line.js";
import { Polygon } from "../shapes/Polygon.js";
import { Polyline } from "../shapes/Polyline.js";
import { Rectangle } from "../shapes/Rectangle.js";
import { Shape } from "../shapes/Shapes.js";
import { Text } from "../shapes/Text.js";
import * as ad from "../types/ad.js";
export type Rectlike<T> = Equation<T> | Image<T> | Rectangle<T> | Text<T>;
export type Polygonlike<T> = Rectlike<T> | Line<T> | Polygon<T> | Polyline<T>;
export type Linelike<T> = Line<T>;
export declare const isRectlike: <T>(s: Shape<T>) => s is Rectlike<T>;
export declare const isPolygonlike: <T>(s: Shape<T>) => s is Polygonlike<T>;
export declare const isLinelike: <T>(s: Shape<T>) => s is Linelike<T>;
export declare const bboxPts: (s: Shape<ad.Num>) => [ad.Pt2, ad.Pt2, ad.Pt2, ad.Pt2];
export declare const toPt: (v: ad.Num[]) => ad.Pt2;
/**
 * Require that a shape at `center1` with radius `r1` not intersect a shape at `center2` with radius `r2` with optional padding `padding`. (For a non-circle shape, its radius should be half of the shape's general "width")
 */
export declare const noIntersectCircles: (center1: ad.Num[], r1: ad.Num, center2: ad.Num[], r2: ad.Num, padding?: number) => ad.Num;
/**
 * Return true iff `p` is in rect `b`.
 */
export declare const pointInBox: (p: ad.Pt2, rect: BBox.BBox) => ad.Bool;
/**
 * Helper function for atDist constraint.
 * If the point is outside the box, try to get the distance from the point to equal the desired distance.
 */
export declare const atDistOutside: (pt: ad.Pt2, rect: BBox.BBox, offset: ad.Num) => ad.Num;
/**
 * Return the amount of overlap between two intervals in R. (0 if none)
 */
export declare const overlap1D: ([l1, r1]: [ad.Num, ad.Num], [l2, r2]: [ad.Num, ad.Num]) => ad.Num;
/**
 * Return numerically-encoded boolean indicating whether `x \in [l, r]`.
 */
export declare const inRange: (x: ad.Num, l: ad.Num, r: ad.Num) => ad.Bool;
/**
 * Sample a line `line` at `NUM_SAMPLES` points uniformly.
 */
export declare const sampleSeg: (line: ad.Num[][]) => ad.Pt2[];
/**
 * Repel a vector `a` from a vector `b` with weight `c`.
 */
export declare const repelPoint: (c: ad.Num, a: ad.Num[], b: ad.Num[]) => ad.Num;
/**
 * Clamp `x` in range `[l, r]`.
 */
export declare const clamp: ([l, r]: [ad.Num, ad.Num], x: ad.Num) => ad.Num;
/**
 * Return the closest point on segment `[start, end]` to point `pt`.
 */
export declare const closestPt_PtSeg: (pt: ad.Num[], [start, end]: ad.Num[][]) => ad.Num[];
/**
 * Get numerical values of nodes in the computation graph. This function calls `secondaryGraph` to construct a partial computation graph and runs `genCode` to generate code to evaluate the values.
 *
 * @param xs nodes in the computation graph
 * @returns a list of `number`s corresponding to nodes in `xs`
 */
export declare const numsOf: (xs: ad.Num[]) => number[];
export declare const numOf: (x: ad.Num) => number;
/**
 * Return list of tuples of consecutive items
 */
export declare const consecutiveTuples: <T>(items: T[], closed: boolean) => [T, T][];
/**
 * Return list of triples of consecutive items
 */
export declare const consecutiveTriples: <T>(items: T[], closed: boolean) => [T, T, T][];
/**
 * Return indicator of closed Polyline, Polygon or Path shape
 */
export declare const isClosed: (s: Shape<ad.Num>) => boolean;
/**
 * Return list of points from Polyline, Polygon or Path shape
 */
export declare const extractPoints: (s: Shape<ad.Num>) => [ad.Num, ad.Num][];
export declare const relu: (x: ad.Num) => ad.Num;
//# sourceMappingURL=Utils.d.ts.map