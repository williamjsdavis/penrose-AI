import { Line } from "../shapes/Line.js";
import { Shape } from "../shapes/Shapes.js";
import * as ad from "../types/ad.js";
import { MayWarn } from "../types/functions.js";
import { ClipData } from "../types/value.js";
export declare const andConstraint: (...xs: ad.Num[]) => ad.Num;
/**
 * Require that the value `x` is equal to the value `y`
 */
export declare const equal: (x: ad.Num, y: ad.Num) => ad.Num;
/**
 * Require that the value `x` is less than the value `y` with optional padding `padding`
 */
export declare const lessThan: (x: ad.Num, y: ad.Num, padding?: number) => ad.Num;
/**
 * Require that the value `x` is greater than the value `y` with optional padding `padding`
 */
export declare const greaterThan: (x: ad.Num, y: ad.Num, padding?: number) => ad.Num;
/**
 * Require that the value `x` is less than the value `y`, with steeper penalty
 */
export declare const lessThanSq: (x: ad.Num, y: ad.Num) => ad.Num;
/**
 * Require that the value `x` is greater than the value `y`, with steeper penalty
 */
export declare const greaterThanSq: (x: ad.Num, y: ad.Num) => ad.Num;
/**
 * Require that the value `x` is in the range defined by `[x0, x1]`.
 */
export declare const inRange: (x: ad.Num, x0: ad.Num, x1: ad.Num) => ad.Num;
/**
 * Require that an interval `[l1, r1]` contains another interval `[l2, r2]`. If not possible, returns 0.
 */
export declare const contains1D: ([l1, r1]: [ad.Num, ad.Num], [l2, r2]: [ad.Num, ad.Num]) => ad.Num;
/**
 * Make scalar `c` disjoint from a range `left, right`.
 */
export declare const disjointScalar: (c: ad.Num, left: ad.Num, right: ad.Num) => ad.Num;
/**
 * Require that the vector defined by `(q, p)` is perpendicular from the vector defined by `(r, p)`.
 */
export declare const perpendicular: (q: ad.Num[], p: ad.Num[], r: ad.Num[]) => ad.Num;
/**
 * Require that three points be collinear.
 * Does not enforce a specific ordering of points, instead it takes the arrangement of points that is most easily satisfiable.
 */
export declare const collinear: (c1: ad.Num[], c2: ad.Num[], c3: ad.Num[]) => ad.Num;
/**
 * Require that three points be collinear.
 * Depends on the specific ordering of points.
 */
export declare const collinearOrdered: (c1: ad.Num[], c2: ad.Num[], c3: ad.Num[]) => ad.Num;
/** Require that `shape` is on the canvas */
export declare const onCanvas: (shape: Shape<ad.Num>, canvasWidth: ad.Num, canvasHeight: ad.Num) => ad.Num;
export declare const overlapping: (s1: Shape<ad.Num>, s2: Shape<ad.Num>, overlap?: ad.Num) => MayWarn<ad.Num>;
export declare const overlappingEllipses: (c1: ad.Pt2, rx1: ad.Num, ry1: ad.Num, c2: ad.Pt2, rx2: ad.Num, ry2: ad.Num, overlap: ad.Num) => ad.Num;
export declare const overlappingCircleEllipse: (c1: ad.Pt2, r1: ad.Num, c2: ad.Pt2, rx2: ad.Num, ry2: ad.Num, overlap: ad.Num) => ad.Num;
export declare const disjoint: (s1: Shape<ad.Num>, s2: Shape<ad.Num>, padding?: ad.Num) => MayWarn<ad.Num>;
export declare const touching: (s1: Shape<ad.Num>, s2: Shape<ad.Num>, padding?: ad.Num) => MayWarn<ad.Num>;
export declare const contains: (s1: Shape<ad.Num>, s2: Shape<ad.Num>, padding?: ad.Num) => MayWarn<ad.Num>;
export declare const containsCircles: (c1: ad.Pt2, r1: ad.Num, c2: ad.Pt2, r2: ad.Num, padding: ad.Num) => ad.Num;
export declare const containsPolys: (pts1: ad.Pt2[], pts2: ad.Pt2[], padding: ad.Num) => ad.Num;
export declare const containsPolyCircle: (pts: ad.Pt2[], c: ad.Pt2, r: ad.Num, padding: ad.Num) => ad.Num;
export declare const containsPolyPoint: (pts: ad.Pt2[], pt: ad.Pt2, padding: ad.Num) => ad.Num;
export declare const containsCirclePoint: (c: ad.Pt2, r: ad.Num, pt: ad.Pt2, padding: ad.Num) => ad.Num;
export declare const containsCirclePoly: (c: ad.Pt2, r: ad.Num, pts: ad.Pt2[], padding: ad.Num) => ad.Num;
export declare const containsCircleRect: (c: ad.Pt2, r: ad.Num, rect: ad.Pt2[], padding: ad.Num) => ad.Num;
export declare const containsRectCircle: (rect: ad.Pt2[], c: ad.Pt2, r: ad.Num, padding: ad.Num) => ad.Num;
export declare const containsRects: (rect1: ad.Pt2[], rect2: ad.Pt2[], padding: ad.Num) => ad.Num;
export declare const containsGroupShape: (shapes: Shape<ad.Num>[], clip: ClipData<ad.Num>, s2: Shape<ad.Num>, padding: ad.Num) => MayWarn<ad.Num>;
/**
 * Make two intervals disjoint. They must be 1D intervals (line-like shapes) sharing a y-coordinate.
 */
export declare const disjointIntervals: (s1: Line<ad.Num>, s2: Line<ad.Num>) => ad.Num;
export declare const constrDict: {
    disjointIntervals: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ShapeT;
        }[];
        body: (s1: Line<ad.Num>, s2: Line<ad.Num>) => MayWarn<ad.Num>;
    };
    onCanvas: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ShapeT;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        })[];
        body: (shape: Shape<ad.Num>, canvasWidth: ad.Num, canvasHeight: ad.Num) => MayWarn<ad.Num>;
    };
    /**
     * Require that shape `s1` overlaps shape `s2` with some overlap `overlap`.
     * based on the type of the shape, and with an optional `overlap` between them
     * (e.g. if `s1` should be overlapping `s2` with margin `overlap`).
     */
    overlapping: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ShapeT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (s1: Shape<ad.Num>, s2: Shape<ad.Num>, overlap?: ad.Num) => MayWarn<ad.Num>;
    };
    overlappingEllipses: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (c1: ad.Pt2, rx1: ad.Num, ry1: ad.Num, c2: ad.Pt2, rx2: ad.Num, ry2: ad.Num, overlap: ad.Num) => MayWarn<ad.Num>;
    };
    overlappingCircleEllipse: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (c1: ad.Pt2, r1: ad.Num, c2: ad.Pt2, rx2: ad.Num, ry2: ad.Num, overlap: ad.Num) => MayWarn<ad.Num>;
    };
    /**
     * Require that a shape `s1` is disjoint from shape `s2`,
     * based on the type of the shape, and with an optional `padding` between them
     * (e.g. if `s1` should be disjoint from `s2` with margin `padding`).
     */
    disjoint: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ShapeT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (s1: Shape<ad.Num>, s2: Shape<ad.Num>, padding?: ad.Num) => MayWarn<ad.Num>;
    };
    /**
     * Require that shape `s1` is touching shape `s2`.
     * based on the type of the shape, and with an optional `padding` between them
     * (e.g. if `s1` should be touching `s2` with margin `padding`).
     */
    touching: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ShapeT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (s1: Shape<ad.Num>, s2: Shape<ad.Num>, padding?: ad.Num) => MayWarn<ad.Num>;
    };
    /**
     * Require that a shape `s1` contains another shape `s2`,
     * based on the type of the shape, and with an optional `padding` between the sizes of the shapes
     * (e.g. if `s1` should contain `s2` with margin `padding`).
     */
    contains: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ShapeT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (s1: Shape<ad.Num>, s2: Shape<ad.Num>, padding?: ad.Num) => MayWarn<ad.Num>;
    };
    containsCircles: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (c1: ad.Pt2, r1: ad.Num, c2: ad.Pt2, r2: ad.Num, padding: ad.Num) => MayWarn<ad.Num>;
    };
    containsPolys: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (pts1: ad.Pt2[], pts2: ad.Pt2[], padding: ad.Num) => MayWarn<ad.Num>;
    };
    containsPolyCircle: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (pts: ad.Pt2[], c: ad.Pt2, r: ad.Num, padding: ad.Num) => MayWarn<ad.Num>;
    };
    containsPolyPoint: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (pts: ad.Pt2[], pt: ad.Pt2, padding: ad.Num) => MayWarn<ad.Num>;
    };
    containsCirclePoint: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (c: ad.Pt2, r: ad.Num, pt: ad.Pt2, padding: ad.Num) => MayWarn<ad.Num>;
    };
    containsCirclePoly: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (c: ad.Pt2, r: ad.Num, pts: ad.Pt2[], padding: ad.Num) => MayWarn<ad.Num>;
    };
    containsCircleRect: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (c: ad.Pt2, r: ad.Num, rect: ad.Pt2[], padding: ad.Num) => MayWarn<ad.Num>;
    };
    containsRectCircle: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (rect: ad.Pt2[], c: ad.Pt2, r: ad.Num, padding: ad.Num) => MayWarn<ad.Num>;
    };
    containsRects: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (rect1: ad.Pt2[], rect2: ad.Pt2[], padding: ad.Num) => MayWarn<ad.Num>;
    };
    equal: {
        name: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (x: ad.Num, y: ad.Num) => MayWarn<ad.Num>;
    };
    lessThan: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (x: ad.Num, y: ad.Num, padding?: number | undefined) => MayWarn<ad.Num>;
    };
    greaterThan: {
        name: string;
        description: string;
        params: ({
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default?: undefined;
        } | {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
            default: number;
        })[];
        body: (x: ad.Num, y: ad.Num, padding?: number | undefined) => MayWarn<ad.Num>;
    };
    lessThanSq: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (x: ad.Num, y: ad.Num) => MayWarn<ad.Num>;
    };
    greaterThanSq: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (x: ad.Num, y: ad.Num) => MayWarn<ad.Num>;
    };
    inRange: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (x: ad.Num, x0: ad.Num, x1: ad.Num) => MayWarn<ad.Num>;
    };
    contains1D: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (args_0: [ad.Num, ad.Num], args_1: [ad.Num, ad.Num]) => MayWarn<ad.Num>;
    };
    disjointScalar: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (c: ad.Num, left: ad.Num, right: ad.Num) => MayWarn<ad.Num>;
    };
    perpendicular: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (q: ad.Num[], p: ad.Num[], r: ad.Num[]) => MayWarn<ad.Num>;
    };
    collinear: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (c1: ad.Num[], c2: ad.Num[], c3: ad.Num[]) => MayWarn<ad.Num>;
    };
    collinearOrdered: {
        name: string;
        description: string;
        params: {
            name: string;
            description: string;
            type: import("../types/types.js").ValueT;
        }[];
        body: (c1: ad.Num[], c2: ad.Num[], c3: ad.Num[]) => MayWarn<ad.Num>;
    };
};
//# sourceMappingURL=Constraints.d.ts.map