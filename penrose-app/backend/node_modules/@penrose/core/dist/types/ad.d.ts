import GenericGraph from "../utils/Graph.js";
export type Expr = Bool | Num | Vec;
export type Bool = Comp | Logic | Not;
export type Num = number | Var | Unary | Binary | Ternary | Nary | Index;
export type Vec = PolyRoots;
export interface Var {
    tag: "Var";
    val: number;
}
export interface Unary extends UnaryNode {
    param: Num;
}
export interface Binary extends BinaryNode {
    left: Num;
    right: Num;
}
export interface Comp extends CompNode {
    left: Num;
    right: Num;
}
export interface Logic extends LogicNode {
    left: Bool;
    right: Bool;
}
export interface Not extends NotNode {
    param: Bool;
}
export interface Ternary extends TernaryNode {
    cond: Bool;
    then: Num;
    els: Num;
}
export interface Nary extends NaryNode {
    params: Num[];
}
export interface PolyRoots extends PolyRootsNode {
    coeffs: Num[];
}
export interface Index extends IndexNode {
    vec: Vec;
}
export type Node = ConstNode | InputNode | UnaryNode | BinaryNode | CompNode | LogicNode | TernaryNode | NaryNode | PolyRootsNode | IndexNode | NotNode;
export interface ConstNode {
    tag: "Const";
    val: number;
}
export interface InputNode {
    tag: "Var";
    key: number;
}
export interface UnaryNode {
    tag: "Unary";
    unop: "neg" | "squared" | "sqrt" | "inverse" | "abs" | "acosh" | "acos" | "asin" | "asinh" | "atan" | "atanh" | "cbrt" | "ceil" | "cos" | "cosh" | "exp" | "expm1" | "floor" | "log" | "log2" | "log10" | "log1p" | "round" | "sign" | "sin" | "sinh" | "tan" | "tanh" | "trunc";
}
export interface BinaryNode {
    tag: "Binary";
    binop: "+" | "*" | "-" | "/" | "max" | "min" | "atan2" | "pow";
}
export interface CompNode {
    tag: "Comp";
    binop: ">" | "<" | "===" | ">=" | "<=";
}
export interface NotNode {
    tag: "Not";
}
export interface LogicNode {
    tag: "Logic";
    binop: "&&" | "||" | "!==";
}
export interface TernaryNode {
    tag: "Ternary";
}
export interface NaryNode {
    tag: "Nary";
    op: "addN" | "maxN" | "minN";
}
export interface PolyRootsNode {
    tag: "PolyRoots";
    degree: number;
}
export interface IndexNode {
    tag: "Index";
    index: number;
}
export type Edge = number;
export type Id = number;
export interface Graph extends Outputs<Id> {
    graph: GenericGraph<Id, Node, Edge>;
    nodes: Map<Expr, Id>;
}
/**
 * A structure used to collect the various outputs of a `Gradient` function.
 * This is generic in the concrete number type, because it can also be useful in
 * situations where the elements are, for instance, computation graph nodes.
 */
export interface Outputs<T> {
    /** Derivatives of primary output with respect to inputs. */
    gradient: Map<Var, T>;
    /** Primary output. */
    primary: T;
    /** Secondary outputs. */
    secondary: T[];
}
export type Compiled = (inputs: (x: Var) => number, mask?: boolean[]) => Outputs<number>;
export interface OptOutputs {
    phi: number;
    objectives: number[];
    constraints: number[];
}
export interface Masks {
    inputMask: boolean[];
    objMask: boolean[];
    constrMask: boolean[];
}
export type Gradient = (masks: Masks, inputs: Float64Array, weight: number, grad: Float64Array) => OptOutputs;
export interface Description {
    /** zero by default */
    objective?: Num;
    /** empty by default */
    constraints?: Num[];
}
export interface Options {
    /** always false by default */
    until?(): boolean;
}
export interface Run {
    converged: boolean;
    /** doesn't include frozen */
    vals: Map<Var, number>;
    /** returns a new `Run`, leaving this one unchanged */
    run(opts: Options): Run;
}
export interface Config {
    /** uses `val` field by default */
    vals?(x: Var): number;
    /** always false by default */
    freeze?(x: Var): boolean;
}
export interface Problem {
    start(config: Config): Run;
}
export type Pt2 = [Num, Num];
export declare const isPt2: (vec: Num[]) => vec is Pt2;
//# sourceMappingURL=ad.d.ts.map