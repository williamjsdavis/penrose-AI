import { Result } from "true-myth";
import { badArgumentTypeError, functionInternalError, missingArgumentError, tooManyArgumentsError, } from "../utils/Error.js";
import { checkType } from "./StyleTypeChecker.js";
const { ok, err } = Result;
export const callCompFunc = (func, range, context, args) => {
    const checkedArgs = checkArgs(func, range, args);
    if (checkedArgs.isErr())
        return err(checkedArgs.error);
    try {
        const { value, warnings } = func.body(context, ...checkedArgs.value);
        return ok({
            value,
            warnings: warnings.map((w) => {
                // Attach location information to the top of `BBoxApproximationWarnings`
                // since only the top stack element is resulted from the user call to Style function
                if (w.tag === "BBoxApproximationWarning") {
                    w.stack[w.stack.length - 1].location = range;
                }
                return w;
            }),
        });
    }
    catch (e) {
        if (e instanceof Error) {
            return err(functionInternalError(func, range, e.message));
        }
        else {
            throw new Error("Function call resulted in exception not of Error type");
        }
    }
};
export const callObjConstrFunc = (func, range, args) => {
    const checkedArgs = checkArgs(func, range, args);
    if (checkedArgs.isErr())
        return err(checkedArgs.error);
    try {
        const { value, warnings } = func.body(...checkedArgs.value);
        return ok({
            value,
            warnings: warnings.map((w) => {
                // Attach location information to the top of `BBoxApproximationWarnings`
                // since only the top stack element is resulted from the user call to Style function
                if (w.tag === "BBoxApproximationWarning") {
                    w.stack[w.stack.length - 1].location = range;
                }
                return w;
            }),
        });
    }
    catch (e) {
        if (e instanceof Error) {
            return err(functionInternalError(func, range, e.message));
        }
        else {
            throw new Error("Function call resulted in exception not of Error type");
        }
    }
};
export const checkArgs = (func, range, args) => {
    if (args.length > func.params.length) {
        return err(tooManyArgumentsError(func, range, args.length));
    }
    const vals = [];
    for (let i = 0; i < func.params.length; i++) {
        const funcArg = func.params[i];
        const arg = args[i];
        const v = checkArg(func.name, range, funcArg, arg);
        if (v.isErr())
            return err(v.error);
        vals.push(v.value);
    }
    return ok(vals);
};
export const checkArg = (funcName, location, funcArg, arg) => {
    // If the argument is not provided
    if (!arg) {
        // But if the argument has a default value
        if (funcArg.default !== undefined) {
            // Use the default value.
            return ok(funcArg.default);
        }
        else {
            // Otherwise report error.
            return err(missingArgumentError(funcName, funcArg, location));
        }
    }
    // The argument is provided.
    const result = checkType(funcArg.type, arg);
    if (result !== undefined)
        return ok(result);
    return err(badArgumentTypeError(funcName, funcArg, arg));
};
//# sourceMappingURL=StyleFunctionCaller.js.map