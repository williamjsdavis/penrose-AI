// Utils that are unrelated to the engine, but autodiff/opt/etc only
import { safe } from "../utils/Util.js";
import { genCode, secondaryGraph } from "./Autodiff.js";
// TODO: Is there a way to write these mapping/conversion functions with less boilerplate?
// For wrapping temp Style errors until figuring out how they should be categorized
export const wrapErr = (s) => {
    return {
        tag: "GenericStyleError",
        messages: [s],
    };
};
// TODO(errors): should these kinds of errors be caught by block statics rather than failing at runtime?
export const runtimeValueTypeError = (path, expectedType, actualType) => {
    return {
        tag: "RuntimeValueTypeError",
        path,
        expectedType,
        actualType,
    };
};
// Generic utils for mapping over values
export function mapTuple(f, t) {
    return t.map((tup) => {
        return f(tup);
    });
}
export function mapTupNested(f, t) {
    return t.map((tup) => {
        return mapTuple(f, tup);
    });
}
// Mapping over values
function mapFloat(f, v) {
    return {
        tag: "FloatV",
        contents: f(v.contents),
    };
}
function mapPtList(f, v) {
    return {
        tag: "PtListV",
        contents: mapTupNested(f, v.contents),
    };
}
function mapList(f, v) {
    return {
        tag: "ListV",
        contents: v.contents.map(f),
    };
}
function mapVector(f, v) {
    return {
        tag: "VectorV",
        contents: v.contents.map(f),
    };
}
function mapTup(f, v) {
    return {
        tag: "TupV",
        contents: mapTuple(f, v.contents),
    };
}
function mapLList(f, v) {
    return {
        tag: "LListV",
        contents: v.contents.map((e) => e.map(f)),
    };
}
function mapMatrix(f, v) {
    return {
        tag: "MatrixV",
        contents: v.contents.map((e) => e.map(f)),
    };
}
// convert all `ad.Num`s to numbers for use in Shape def
function mapPathData(f, v) {
    return {
        tag: "PathDataV",
        contents: v.contents.map((pathCmd) => {
            return {
                cmd: pathCmd.cmd,
                contents: pathCmd.contents.map((subCmd) => {
                    return {
                        tag: subCmd.tag,
                        contents: mapTuple(f, subCmd.contents),
                    };
                }),
            };
        }),
    };
}
function mapColorInner(f, v) {
    switch (v.tag) {
        case "RGBA":
            return { tag: v.tag, contents: mapTuple(f, v.contents) };
        case "HSVA":
            return { tag: v.tag, contents: mapTuple(f, v.contents) };
        case "NONE":
            return { tag: v.tag };
    }
}
function mapColor(f, v) {
    return {
        tag: "ColorV",
        contents: mapColorInner(f, v.contents),
    };
}
function mapShape(f, v) {
    switch (v.shapeType) {
        case "Circle":
            return mapCircle(f, v);
        case "Ellipse":
            return mapEllipse(f, v);
        case "Equation":
            return mapEquation(f, v);
        case "Image":
            return mapImage(f, v);
        case "Line":
            return mapLine(f, v);
        case "Path":
            return mapPath(f, v);
        case "Polygon":
            return mapPolygon(f, v);
        case "Polyline":
            return mapPolyline(f, v);
        case "Rectangle":
            return mapRectangle(f, v);
        case "Text":
            return mapText(f, v);
        case "Group":
            return mapGroup(f, v);
    }
}
function mapShapeList(f, v) {
    return {
        tag: "ShapeListV",
        contents: v.contents.map((shape) => {
            return mapShape(f, shape);
        }),
    };
}
function mapClipData(f, v) {
    return {
        tag: "ClipDataV",
        contents: mapClipDataInner(f, v.contents),
    };
}
function mapClipDataInner(f, v) {
    if (v.tag === "NoClip") {
        return { tag: "NoClip" };
    }
    else {
        const mapped = mapShape(f, v.contents);
        if (mapped.shapeType === "Group") {
            throw new Error("Got a Group shape in mapClipDataInner");
        }
        return { tag: "Clip", contents: mapped };
    }
}
const mapCircle = (f, v) => {
    return {
        ...v,
        ...mapNamed(f, v),
        ...mapStroke(f, v),
        ...mapFill(f, v),
        ...mapCenter(f, v),
        r: mapFloat(f, v.r),
        passthrough: mapPassthrough(f, v.passthrough),
    };
};
const mapEllipse = (f, v) => {
    return {
        ...v,
        ...mapNamed(f, v),
        ...mapStroke(f, v),
        ...mapFill(f, v),
        ...mapCenter(f, v),
        rx: mapFloat(f, v.rx),
        ry: mapFloat(f, v.ry),
        passthrough: mapPassthrough(f, v.passthrough),
    };
};
const mapEquation = (f, v) => {
    return {
        ...v,
        ...mapNamed(f, v),
        ...mapFill(f, v),
        ...mapCenter(f, v),
        ...mapRect(f, v),
        ...mapRotate(f, v),
        ...mapString(f, v),
        ascent: mapFloat(f, v.ascent),
        descent: mapFloat(f, v.descent),
        passthrough: mapPassthrough(f, v.passthrough),
    };
};
const mapGroup = (f, v) => {
    return {
        ...v,
        ...mapNamed(f, v),
        shapes: mapShapeList(f, v.shapes),
        clipPath: mapClipData(f, v.clipPath),
        passthrough: mapPassthrough(f, v.passthrough),
    };
};
const mapImage = (f, v) => {
    return {
        ...v,
        ...mapNamed(f, v),
        ...mapCenter(f, v),
        ...mapRect(f, v),
        ...mapRotate(f, v),
        href: v.href,
        passthrough: mapPassthrough(f, v.passthrough),
    };
};
const mapLine = (f, v) => {
    return {
        ...v,
        ...mapNamed(f, v),
        ...mapStroke(f, v),
        ...mapFill(f, v),
        ...mapArrow(f, v),
        start: mapVector(f, v.start),
        end: mapVector(f, v.end),
        strokeLinecap: v.strokeLinecap,
        passthrough: mapPassthrough(f, v.passthrough),
    };
};
const mapPath = (f, v) => {
    return {
        ...v,
        ...mapNamed(f, v),
        ...mapStroke(f, v),
        ...mapFill(f, v),
        ...mapArrow(f, v),
        d: mapPathData(f, v.d),
        passthrough: mapPassthrough(f, v.passthrough),
    };
};
const mapPolygon = (f, v) => {
    return {
        ...v,
        ...mapNamed(f, v),
        ...mapStroke(f, v),
        ...mapFill(f, v),
        ...mapScale(f, v),
        ...mapPoly(f, v),
        passthrough: mapPassthrough(f, v.passthrough),
    };
};
const mapPolyline = (f, v) => {
    return {
        ...v,
        ...mapNamed(f, v),
        ...mapStroke(f, v),
        ...mapFill(f, v),
        ...mapScale(f, v),
        ...mapPoly(f, v),
        passthrough: mapPassthrough(f, v.passthrough),
    };
};
const mapRectangle = (f, v) => {
    return {
        ...v,
        ...mapNamed(f, v),
        ...mapStroke(f, v),
        ...mapFill(f, v),
        ...mapCenter(f, v),
        ...mapRotate(f, v),
        ...mapRect(f, v),
        ...mapCorner(f, v),
        passthrough: mapPassthrough(f, v.passthrough),
    };
};
const mapText = (f, v) => {
    return {
        ...v,
        ...mapNamed(f, v),
        ...mapStroke(f, v),
        ...mapFill(f, v),
        ...mapCenter(f, v),
        ...mapRotate(f, v),
        ...mapRect(f, v),
        ...mapString(f, v),
        ascent: mapFloat(f, v.ascent),
        descent: mapFloat(f, v.descent),
        passthrough: mapPassthrough(f, v.passthrough),
    };
};
const mapPassthrough = (f, v) => {
    const vMapped = new Map();
    for (const [key, value] of v.entries()) {
        if (value.tag === "StrV") {
            vMapped.set(key, value);
        }
        else {
            vMapped.set(key, mapFloat(f, value));
        }
    }
    return vMapped;
};
const mapNamed = (f, v) => {
    // Cannot use "spread" operator since `v` might have more things than just Named.
    return { name: v.name, ensureOnCanvas: v.ensureOnCanvas };
};
const mapStroke = (f, v) => {
    return {
        strokeStyle: v.strokeStyle,
        strokeDasharray: v.strokeDasharray,
        strokeWidth: mapFloat(f, v.strokeWidth),
        strokeColor: mapColor(f, v.strokeColor),
    };
};
const mapFill = (f, v) => {
    return { fillColor: mapColor(f, v.fillColor) };
};
const mapCenter = (f, v) => {
    return { center: mapVector(f, v.center) };
};
const mapRect = (f, v) => {
    return { width: mapFloat(f, v.width), height: mapFloat(f, v.height) };
};
const mapArrow = (f, v) => {
    return {
        startArrowhead: v.startArrowhead,
        endArrowhead: v.endArrowhead,
        flipStartArrowhead: v.flipStartArrowhead,
        startArrowheadSize: mapFloat(f, v.startArrowheadSize),
        endArrowheadSize: mapFloat(f, v.endArrowheadSize),
    };
};
const mapCorner = (f, v) => {
    return { cornerRadius: mapFloat(f, v.cornerRadius) };
};
const mapRotate = (f, v) => {
    return { rotation: mapFloat(f, v.rotation) };
};
const mapScale = (f, v) => {
    return { scale: mapFloat(f, v.scale) };
};
const mapPoly = (f, v) => {
    return { points: mapPtList(f, v.points) };
};
const mapString = (f, v) => {
    return { string: v.string, fontSize: v.fontSize };
};
// Utils for converting types of values
// Expects `f` to be a function between numeric types (e.g. number -> ad.Num, ad.Num -> number, AD var -> ad.Num ...)
// Coerces any non-numeric types
export function mapValueNumeric(f, v) {
    switch (v.tag) {
        case "FloatV":
            return mapFloat(f, v);
        case "PtListV":
            return mapPtList(f, v);
        case "ListV":
            return mapList(f, v);
        case "VectorV":
            return mapVector(f, v);
        case "MatrixV":
            return mapMatrix(f, v);
        case "TupV":
            return mapTup(f, v);
        case "LListV":
            return mapLList(f, v);
        case "ColorV":
            return mapColor(f, v);
        case "PathDataV":
            return mapPathData(f, v);
        case "ShapeListV":
            return mapShapeList(f, v);
        case "ClipDataV":
            return mapClipData(f, v);
        // non-numeric Value types
        case "BoolV":
        case "StrV":
            return v;
    }
}
export const compileCompGraph = async (inputs, shapes) => {
    const indices = new Map(inputs.map((x, i) => [x, i]));
    const vars = [];
    for (const s of shapes) {
        // a bit weird since it feels somewhat wasteful to reconstruct the new
        // shape, but this reduces some code duplication since this way we don't
        // have to write a separate function to collect all the `ad.Num`s
        mapShape((x) => {
            vars.push(x);
        }, s);
    }
    const compGraph = secondaryGraph(vars);
    const evalFn = await genCode(compGraph);
    return (xs) => {
        const numbers = evalFn((x) => xs[safe(indices.get(x), "input not found")]).secondary;
        const m = new Map(compGraph.secondary.map((id, i) => [id, numbers[i]]));
        return shapes.map((s) => mapShape((x) => safe(m.get(safe(compGraph.nodes.get(x), `missing node`)), "missing output"), s));
    };
};
//#region translation operations
export const dummySourceLoc = () => {
    return { line: -1, col: -1 };
};
export const isConcrete = (node) => node.nodeType === "Substance" ||
    node.nodeType === "Style" ||
    node.nodeType === "Domain";
// COMBAK: Make fake identifier from string (e.g. if we don't have a source loc, make fake source loc)
export const dummyIdentifier = (name, nodeType) => {
    return {
        nodeType,
        type: "value",
        value: name,
        tag: "Identifier",
    };
};
//#endregion
export const exprToNumber = (e) => {
    if (e.tag === "Fix") {
        return e.contents;
    }
    throw Error("expecting expr to be number");
};
//# sourceMappingURL=EngineUtils.js.map