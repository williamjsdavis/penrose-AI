import { add, div, maxN, minN, sub } from "../engine/AutodiffFunctions.js";
import * as BBox from "../engine/BBox.js";
import { sampleCircle } from "./Circle.js";
import { sampleEllipse } from "./Ellipse.js";
import { sampleEquation } from "./Equation.js";
import { sampleGroup } from "./Group.js";
import { sampleImage } from "./Image.js";
import { sampleLine } from "./Line.js";
import { samplePath } from "./Path.js";
import { samplePolygon } from "./Polygon.js";
import { samplePolyline } from "./Polyline.js";
import { sampleRectangle } from "./Rectangle.js";
import { sampleText } from "./Text.js";
export const computeShapeBbox = (shape) => {
    switch (shape.shapeType) {
        case "Circle":
            return BBox.bboxFromCircle(shape);
        case "Ellipse":
            return BBox.bboxFromEllipse(shape);
        case "Equation":
        case "Image":
        case "Text":
            return BBox.bboxFromRectlike(shape);
        case "Line":
            return BBox.bboxFromLinelike(shape);
        case "Path":
            return BBox.bboxFromPath(shape);
        case "Polygon":
        case "Polyline":
            return BBox.bboxFromPolygon(shape);
        case "Rectangle":
            return BBox.bboxFromRect(shape);
        case "Group":
            return bboxFromGroup(shape);
    }
};
const shapeSampler = new Map(Object.entries({
    Circle: sampleCircle,
    Ellipse: sampleEllipse,
    Equation: sampleEquation,
    Image: sampleImage,
    Line: sampleLine,
    Path: samplePath,
    Polygon: samplePolygon,
    Polyline: samplePolyline,
    Rectangle: sampleRectangle,
    Text: sampleText,
    Group: sampleGroup,
}));
const bboxFromGroup = ({ shapes, clipPath }) => {
    const bboxes = shapes.contents.map((shape) => computeShapeBbox(shape));
    const xRanges = bboxes.map(BBox.xRange);
    const yRanges = bboxes.map(BBox.yRange);
    const minX = minN(xRanges.map((xRange) => xRange[0]));
    const maxX = maxN(xRanges.map((xRange) => xRange[1]));
    const minY = minN(yRanges.map((yRange) => yRange[0]));
    const maxY = maxN(yRanges.map((yRange) => yRange[1]));
    const width = sub(maxX, minX);
    const height = sub(maxY, minY);
    const centerX = div(add(minX, maxX), 2);
    const centerY = div(add(minY, maxY), 2);
    const bboxAllMembers = BBox.bbox(width, height, [centerX, centerY]);
    if (clipPath.contents.tag === "NoClip") {
        return bboxAllMembers;
    }
    const bboxClipPath = computeShapeBbox(clipPath.contents.contents);
    return BBox.intersectBbox(bboxAllMembers, bboxClipPath);
};
export const shapeTypes = [
    "Circle",
    "Ellipse",
    "Equation",
    "Image",
    "Line",
    "Path",
    "Polygon",
    "Polyline",
    "Rectangle",
    "Text",
    "Group",
];
export const sampleShape = (shapeType, context, canvas) => {
    const sampler = shapeSampler.get(shapeType);
    if (sampler) {
        return sampler(context, canvas);
    }
    throw new Error("shapeType not in sampler");
};
// TODO: don't use a type predicate for this
export const isShapeType = (shapeType) => shapeSampler.has(shapeType);
//#endregion
//# sourceMappingURL=Shapes.js.map