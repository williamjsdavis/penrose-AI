import { constrDict } from "./contrib/Constraints.js";
import { elasticEnergy, equivalued, perimeter } from "./contrib/Curves.js";
import { signedDistanceRect } from "./contrib/Functions.js";
import { rectPts } from "./contrib/Queries.js";
import { consecutiveTuples } from "./contrib/Utils.js";
import { ops, variable } from "./engine/Autodiff.js";
import { absVal, add, div, neg, pow, sub } from "./engine/AutodiffFunctions.js";
import { measureText } from "./utils/CollectLabels.js";
export const textBBox = (measure, x, y) => {
    const { height, width, actualDescent } = measure;
    y = add(y, sub(div(height, 2), actualDescent));
    return {
        center: [x, y],
        width,
        height,
    };
};
export const eq = (a, b) => absVal(sub(a, b));
export const dist = (a, b) => ops.vdist(a, b);
export const onCanvasRect = ([canvasWidth, canvasHeight], { center: [x, y], width, height }) => {
    const canvasXRange = [0, canvasWidth];
    const canvasYRange = [0, canvasHeight];
    const hw = div(width, 2);
    const hh = div(height, 2);
    return add(constrDict.contains1D.body(canvasXRange, [sub(x, hw), add(x, hw)]).value, constrDict.contains1D.body(canvasYRange, [sub(y, hh), add(y, hh)]).value);
};
export const onCanvasPoint = ([x, y], canvas) => {
    const [hcw, hch] = [div(canvas[0], 2), div(canvas[1], 2)];
    const xInRange = add(sub(x, neg(hcw)), sub(hcw, x));
    const yInRange = add(sub(y, neg(hch)), sub(hch, y));
    return add(xInRange, yInRange);
};
export const lessThan = (x, y) => sub(x, y);
export { convexPolygonMinkowskiSDF } from "./contrib/Minkowski.js";
export { compile, ops, problem } from "./engine/Autodiff.js";
export * from "./engine/AutodiffFunctions.js";
export { corners } from "./engine/BBox.js";
export { consecutiveTuples, elasticEnergy, equivalued, measureText, perimeter, pow, rectPts, signedDistanceRect, sub, variable, };
//# sourceMappingURL=api.js.map