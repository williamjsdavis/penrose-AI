// Generated automatically by nearley, version 2.20.1
// http://github.com/Hardmath123/nearley
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function id(d) { return d[0]; }
/* eslint-disable */
import moo from "moo";
import _ from 'lodash';
import { optional, basicSymbols, rangeOf, rangeBetween, rangeFrom, nth, convertTokenId } from './ParserUtil.js';
// NOTE: ordering matters here. Top patterns get matched __first__
const lexer = moo.compile({
    ...basicSymbols,
    identifier: {
        match: /[A-z_][A-Za-z_0-9]*/,
        type: moo.keywords({
            // NOTE: the next line add type annotation keywords into the keyword set and thereby forbidding users to use keywords like `shape`
            // "type-keyword": styleTypes, 
            type: "type",
            value: "value",
            constructor: "constructor",
            function: "function",
            predicate: "predicate",
            notation: "notation",
            symmetric: "symmetric",
            prop: "Prop"
        })
    }
});
const nodeData = { nodeType: "Domain" };
;
;
;
;
const grammar = {
    Lexer: lexer,
    ParserRules: [
        { "name": "input", "symbols": ["statements"], "postprocess": ([statements]) => ({
                ...nodeData,
                ...rangeFrom(statements),
                tag: "DomainProg",
                statements
            })
        },
        { "name": "statements", "symbols": ["_"], "postprocess": () => [] },
        { "name": "statements", "symbols": ["_c_", "nl", "statements"], "postprocess": nth(2) },
        { "name": "statements", "symbols": ["_", "statement", "_c_"], "postprocess": d => [d[1]] },
        { "name": "statements", "symbols": ["_", "statement", "_c_", "nl", "statements"], "postprocess": d => [d[1], ...d[4]] },
        { "name": "statement", "symbols": ["type_decl"], "postprocess": id },
        { "name": "statement", "symbols": ["predicate"], "postprocess": id },
        { "name": "statement", "symbols": ["function"], "postprocess": id },
        { "name": "statement", "symbols": ["constructor_decl"], "postprocess": id },
        { "name": "statement", "symbols": ["prelude"], "postprocess": id },
        { "name": "statement", "symbols": ["notation"], "postprocess": id },
        { "name": "statement", "symbols": ["subtype"], "postprocess": id },
        { "name": "type_decl$ebnf$1$subexpression$1", "symbols": ["_", { "literal": "(" }, "_", "type_params", "_", { "literal": ")" }] },
        { "name": "type_decl$ebnf$1", "symbols": ["type_decl$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "type_decl$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "type_decl$ebnf$2$subexpression$1$macrocall$2", "symbols": ["type_constructor"] },
        { "name": "type_decl$ebnf$2$subexpression$1$macrocall$3", "symbols": [{ "literal": "," }] },
        { "name": "type_decl$ebnf$2$subexpression$1$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "type_decl$ebnf$2$subexpression$1$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "type_decl$ebnf$2$subexpression$1$macrocall$3", "_", "type_decl$ebnf$2$subexpression$1$macrocall$2"] },
        { "name": "type_decl$ebnf$2$subexpression$1$macrocall$1$ebnf$1", "symbols": ["type_decl$ebnf$2$subexpression$1$macrocall$1$ebnf$1", "type_decl$ebnf$2$subexpression$1$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "type_decl$ebnf$2$subexpression$1$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "type_decl$ebnf$2$subexpression$1$macrocall$3"] },
        { "name": "type_decl$ebnf$2$subexpression$1$macrocall$1$ebnf$2", "symbols": ["type_decl$ebnf$2$subexpression$1$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "type_decl$ebnf$2$subexpression$1$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "type_decl$ebnf$2$subexpression$1$macrocall$1", "symbols": ["type_decl$ebnf$2$subexpression$1$macrocall$2", "type_decl$ebnf$2$subexpression$1$macrocall$1$ebnf$1", "type_decl$ebnf$2$subexpression$1$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "type_decl$ebnf$2$subexpression$1", "symbols": ["_", { "literal": "<:" }, "_", "type_decl$ebnf$2$subexpression$1$macrocall$1"] },
        { "name": "type_decl$ebnf$2", "symbols": ["type_decl$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "type_decl$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "type_decl", "symbols": [{ "literal": "type" }, "__", "identifier", "type_decl$ebnf$1", "type_decl$ebnf$2"], "postprocess": ([typ, , name, ps, sub]) => {
                const params = ps ? ps[3] : [];
                const superTypes = sub ? sub[3] : [];
                return {
                    ...nodeData,
                    ...rangeBetween(typ, name),
                    tag: "TypeDecl", name, params, superTypes
                };
            }
        },
        { "name": "predicate$ebnf$1$subexpression$1", "symbols": [{ "literal": "symmetric" }, "__"] },
        { "name": "predicate$ebnf$1", "symbols": ["predicate$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "predicate$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "predicate", "symbols": ["predicate$ebnf$1", { "literal": "predicate" }, "__", "identifier", "type_params_list", "args_list"], "postprocess": ([sym, kw, , name, params, args]) => {
                var isSymmetric = sym !== null;
                return {
                    ...nodeData,
                    ...rangeFrom([
                        // If "symmetric" exists, include it.
                        // sym[0] is the token "symmetric";
                        // the rest is white space
                        ...(isSymmetric ? [rangeOf(sym[0])] : []),
                        rangeOf(kw),
                        ...args,
                        ...params
                    ]),
                    tag: "PredicateDecl", name, params, args,
                    // If "symmetric" isn't present, "sym" would be null and this would be false
                    // Otherwise, this would be true.
                    symmetric: isSymmetric
                };
            }
        },
        { "name": "function", "symbols": [{ "literal": "function" }, "__", "identifier", "type_params_list", "args_list", "_", { "literal": "->" }, "_", "arg"], "postprocess": ([kw, , name, ps, as, , , , output]) => {
                const params = optional(ps, []);
                const args = optional(as, []);
                return {
                    ...nodeData,
                    ...rangeBetween(rangeOf(kw), output),
                    tag: "FunctionDecl", name, output, params, args
                };
            }
        },
        { "name": "constructor_decl", "symbols": ["long_constructor_decl"], "postprocess": id },
        { "name": "constructor_decl", "symbols": ["short_constructor_decl"], "postprocess": id },
        { "name": "long_constructor_decl", "symbols": [{ "literal": "constructor" }, "__", "identifier", "type_params_list", "named_args_list", "_", { "literal": "->" }, "_", "arg"], "postprocess": ([kw, , name, ps, as, , , , output]) => {
                const params = optional(ps, []);
                const args = optional(as, []);
                return {
                    ...nodeData,
                    ...rangeBetween(rangeOf(kw), output),
                    tag: "ConstructorDecl", name, output, params, args
                };
            }
        },
        { "name": "short_constructor_decl", "symbols": [{ "literal": "constructor" }, "__", "identifier", "type_params_list", "named_args_list"], "postprocess": ([kw, , name, ps, as]) => {
                const params = optional(ps, []);
                const args = optional(as, []);
                const type = {
                    ...nodeData,
                    ...rangeBetween(rangeOf(kw), name),
                    tag: "TypeConstructor", args: [], name: name
                };
                const output = {
                    ...nodeData,
                    ...rangeBetween(rangeOf(kw), name),
                    tag: "Arg", type, variable: undefined
                };
                return {
                    ...nodeData,
                    ...rangeFrom([rangeOf(kw), ...args]),
                    tag: "ConstructorDecl", name, output, params, args
                };
            }
        },
        { "name": "prelude", "symbols": [{ "literal": "value" }, "__", "var", "_", { "literal": ":" }, "_", "type_constructor"], "postprocess": ([kw, , name, , , , type]) => ({
                ...nodeData,
                ...rangeBetween(rangeOf(kw), type),
                tag: "PreludeDecl", name, type
            })
        },
        { "name": "notation", "symbols": [{ "literal": "notation" }, "_", "string_lit", "_", { "literal": "~" }, "_", "string_lit"], "postprocess": ([kw, , from, , , , to]) => ({
                ...nodeData,
                ...rangeBetween(rangeOf(kw), to),
                tag: "NotationDecl", from, to
            })
        },
        { "name": "subtype", "symbols": ["type_constructor", "_", { "literal": "<:" }, "_", "type_constructor"], "postprocess": ([subType, , , , superType]) => ({
                ...nodeData,
                ...rangeBetween(subType, superType),
                tag: "SubTypeDecl", subType, superType
            })
        },
        { "name": "var", "symbols": ["identifier"], "postprocess": id },
        { "name": "type_var", "symbols": [{ "literal": "'" }, "identifier"], "postprocess": ([a, name]) => ({
                ...nodeData,
                ...rangeBetween(a, name),
                tag: "TypeVar", name
            })
        },
        { "name": "type", "symbols": ["type_var"], "postprocess": id },
        { "name": "type", "symbols": ["type_constructor"], "postprocess": id },
        { "name": "type", "symbols": ["prop"], "postprocess": id },
        { "name": "type_constructor$ebnf$1", "symbols": ["type_arg_list"], "postprocess": id },
        { "name": "type_constructor$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "type_constructor", "symbols": ["identifier", "type_constructor$ebnf$1"], "postprocess": ([name, a]) => {
                const args = optional(a, []);
                return {
                    ...nodeData,
                    ...rangeFrom([name, ...args]),
                    tag: "TypeConstructor", name, args
                };
            }
        },
        { "name": "type_arg_list$macrocall$2", "symbols": ["type"] },
        { "name": "type_arg_list$macrocall$3", "symbols": [{ "literal": "," }] },
        { "name": "type_arg_list$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "type_arg_list$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "type_arg_list$macrocall$3", "_", "type_arg_list$macrocall$2"] },
        { "name": "type_arg_list$macrocall$1$ebnf$1", "symbols": ["type_arg_list$macrocall$1$ebnf$1", "type_arg_list$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "type_arg_list$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "type_arg_list$macrocall$3"] },
        { "name": "type_arg_list$macrocall$1$ebnf$2", "symbols": ["type_arg_list$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "type_arg_list$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "type_arg_list$macrocall$1", "symbols": ["type_arg_list$macrocall$2", "type_arg_list$macrocall$1$ebnf$1", "type_arg_list$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "type_arg_list", "symbols": ["_", { "literal": "(" }, "_", "type_arg_list$macrocall$1", "_", { "literal": ")" }], "postprocess": ([, , , d]) => _.flatten(d) },
        { "name": "type_params_list", "symbols": [], "postprocess": d => [] },
        { "name": "type_params_list", "symbols": ["_", { "literal": "[" }, "_", "type_params", "_", { "literal": "]" }], "postprocess": nth(3) },
        { "name": "type_params$macrocall$2", "symbols": ["type_var"] },
        { "name": "type_params$macrocall$3", "symbols": [{ "literal": "," }] },
        { "name": "type_params$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "type_params$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "type_params$macrocall$3", "_", "type_params$macrocall$2"] },
        { "name": "type_params$macrocall$1$ebnf$1", "symbols": ["type_params$macrocall$1$ebnf$1", "type_params$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "type_params$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "type_params$macrocall$3"] },
        { "name": "type_params$macrocall$1$ebnf$2", "symbols": ["type_params$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "type_params$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "type_params$macrocall$1", "symbols": ["type_params$macrocall$2", "type_params$macrocall$1$ebnf$1", "type_params$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "type_params", "symbols": ["type_params$macrocall$1"], "postprocess": ([d]) => d },
        { "name": "args_list$macrocall$2", "symbols": ["arg"] },
        { "name": "args_list$macrocall$3", "symbols": [{ "literal": "," }] },
        { "name": "args_list$macrocall$1", "symbols": [], "postprocess": d => [] },
        { "name": "args_list$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "args_list$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "args_list$macrocall$3", "_", "args_list$macrocall$2"] },
        { "name": "args_list$macrocall$1$ebnf$1", "symbols": ["args_list$macrocall$1$ebnf$1", "args_list$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "args_list$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "args_list$macrocall$3"] },
        { "name": "args_list$macrocall$1$ebnf$2", "symbols": ["args_list$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "args_list$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "args_list$macrocall$1", "symbols": ["args_list$macrocall$2", "args_list$macrocall$1$ebnf$1", "args_list$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "args_list", "symbols": ["_", { "literal": "(" }, "_", "args_list$macrocall$1", "_", { "literal": ")" }], "postprocess": ([, , , d]) => _.flatten(d) },
        { "name": "arg$ebnf$1$subexpression$1", "symbols": ["__", "var"] },
        { "name": "arg$ebnf$1", "symbols": ["arg$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "arg$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "arg", "symbols": ["type", "arg$ebnf$1"], "postprocess": ([type, v]) => {
                const variable = v ? v[1] : undefined;
                const range = variable ? rangeBetween(variable, type) : rangeOf(type);
                return {
                    ...nodeData,
                    ...range,
                    tag: "Arg", variable, type
                };
            }
        },
        { "name": "named_args_list$macrocall$2", "symbols": ["named_arg"] },
        { "name": "named_args_list$macrocall$3", "symbols": [{ "literal": "," }] },
        { "name": "named_args_list$macrocall$1", "symbols": [], "postprocess": d => [] },
        { "name": "named_args_list$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "named_args_list$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "named_args_list$macrocall$3", "_", "named_args_list$macrocall$2"] },
        { "name": "named_args_list$macrocall$1$ebnf$1", "symbols": ["named_args_list$macrocall$1$ebnf$1", "named_args_list$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "named_args_list$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "named_args_list$macrocall$3"] },
        { "name": "named_args_list$macrocall$1$ebnf$2", "symbols": ["named_args_list$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "named_args_list$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "named_args_list$macrocall$1", "symbols": ["named_args_list$macrocall$2", "named_args_list$macrocall$1$ebnf$1", "named_args_list$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "named_args_list", "symbols": ["_", { "literal": "(" }, "_", "named_args_list$macrocall$1", "_", { "literal": ")" }], "postprocess": ([, , , d]) => _.flatten(d) },
        { "name": "named_arg", "symbols": ["type", "__", "var"], "postprocess": ([type, , variable]) => ({
                ...nodeData,
                ...rangeBetween(type, variable),
                tag: "Arg", variable, type
            })
        },
        { "name": "prop", "symbols": [{ "literal": "Prop" }], "postprocess": ([kw]) => ({
                ...nodeData,
                ...rangeOf(kw),
                tag: "Prop"
            })
        },
        { "name": "string_lit", "symbols": [(lexer.has("string_literal") ? { type: "string_literal" } : string_literal)], "postprocess": ([d]) => ({
                ...nodeData,
                ...rangeOf(d),
                tag: 'StringLit',
                contents: d.value
            })
        },
        { "name": "identifier", "symbols": [(lexer.has("identifier") ? { type: "identifier" } : identifier)], "postprocess": ([d]) => ({
                ...nodeData,
                ...rangeOf(d),
                tag: 'Identifier',
                value: d.text,
                type: "identifier"
            })
        },
        { "name": "comment", "symbols": [(lexer.has("comment") ? { type: "comment" } : comment)], "postprocess": convertTokenId },
        { "name": "comment", "symbols": [(lexer.has("multiline_comment") ? { type: "multiline_comment" } : multiline_comment)], "postprocess": ([d]) => rangeOf(d) },
        { "name": "_c_$ebnf$1", "symbols": [] },
        { "name": "_c_$ebnf$1$subexpression$1", "symbols": [(lexer.has("ws") ? { type: "ws" } : ws)] },
        { "name": "_c_$ebnf$1$subexpression$1", "symbols": ["comment"] },
        { "name": "_c_$ebnf$1", "symbols": ["_c_$ebnf$1", "_c_$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "_c_", "symbols": ["_c_$ebnf$1"] },
        { "name": "_ml$ebnf$1", "symbols": [] },
        { "name": "_ml$ebnf$1", "symbols": ["_ml$ebnf$1", "multi_line_ws_char"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "_ml", "symbols": ["_ml$ebnf$1"] },
        { "name": "multi_line_ws_char", "symbols": [(lexer.has("ws") ? { type: "ws" } : ws)] },
        { "name": "multi_line_ws_char", "symbols": [(lexer.has("nl") ? { type: "nl" } : nl)] },
        { "name": "multi_line_ws_char", "symbols": ["comment"] },
        { "name": "nl", "symbols": [(lexer.has("nl") ? { type: "nl" } : nl)] },
        { "name": "__$ebnf$1", "symbols": [(lexer.has("ws") ? { type: "ws" } : ws)] },
        { "name": "__$ebnf$1", "symbols": ["__$ebnf$1", (lexer.has("ws") ? { type: "ws" } : ws)], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "__", "symbols": ["__$ebnf$1"] },
        { "name": "_$ebnf$1", "symbols": [] },
        { "name": "_$ebnf$1", "symbols": ["_$ebnf$1", (lexer.has("ws") ? { type: "ws" } : ws)], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "_", "symbols": ["_$ebnf$1"] }
    ],
    ParserStart: "input",
};
export default grammar;
//# sourceMappingURL=DomainParser.js.map