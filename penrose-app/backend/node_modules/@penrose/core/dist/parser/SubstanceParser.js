// Generated automatically by nearley, version 2.20.1
// http://github.com/Hardmath123/nearley
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function id(d) { return d[0]; }
/* eslint-disable */
import moo from "moo";
import _ from 'lodash';
import { optional, basicSymbols, rangeOf, rangeBetween, rangeFrom, nth, convertTokenId } from './ParserUtil.js';
// NOTE: ordering matters here. Top patterns get matched __first__
const lexer = moo.compile({
    tex_literal: /\$.*?\$/,
    double_arrow: "<->",
    int_literal: /[+-]?(?<!\.)\b[0-9]+\b(?!\.[0-9])/,
    float_literal: /([+-]?([0-9]*[.])?[0-9]+)/,
    ...basicSymbols,
    identifier: {
        match: /[A-z_][A-Za-z_0-9]*/,
        type: moo.keywords({
            // NOTE: the next line add type annotation keywords into the keyword set and thereby forbidding users to use keywords like `shape`
            // "type-keyword": styleTypes, 
            all: "All",
            label: "Label",
            noLabel: "NoLabel",
            autoLabel: "AutoLabel",
            let: "Let",
            bool_true: "true",
            bool_false: "false",
            for: "for",
            in: "in",
            where: "where",
            mod: "mod",
        })
    }
});
const nodeData = { nodeType: "Substance" };
;
;
;
;
const grammar = {
    Lexer: lexer,
    ParserRules: [
        { "name": "input", "symbols": ["statements"], "postprocess": ([d]) => {
                const statements = _.flatten(d);
                return { ...nodeData, ...rangeFrom(statements), tag: "SubProg", statements };
            }
        },
        { "name": "statements", "symbols": ["_"], "postprocess": () => [] },
        { "name": "statements", "symbols": ["_c_", "nl", "statements"], "postprocess": nth(2) },
        { "name": "statements", "symbols": ["_", "statement", "_c_"], "postprocess": d => [d[1]] },
        { "name": "statements", "symbols": ["_", "statement", "_c_", "nl", "statements"], "postprocess": d => [d[1], ...d[4]] },
        { "name": "statement", "symbols": ["stmt_iset"], "postprocess": id },
        { "name": "statement", "symbols": ["stmt"], "postprocess": id },
        { "name": "stmt_iset", "symbols": ["stmt", "__", "iset"], "postprocess": ([stmt, , iset]) => {
                return {
                    ...nodeData,
                    ...rangeFrom([stmt, iset]),
                    tag: "StmtSet",
                    stmt, iset
                };
            }
        },
        { "name": "iset$macrocall$2", "symbols": ["range_assign"] },
        { "name": "iset$macrocall$3", "symbols": [{ "literal": "," }] },
        { "name": "iset$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "iset$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "iset$macrocall$3", "_", "iset$macrocall$2"] },
        { "name": "iset$macrocall$1$ebnf$1", "symbols": ["iset$macrocall$1$ebnf$1", "iset$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "iset$macrocall$1", "symbols": ["iset$macrocall$2", "iset$macrocall$1$ebnf$1"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "iset", "symbols": [{ "literal": "for" }, "__", "iset$macrocall$1", "__", { "literal": "where" }, "__", "boolean_expr"], "postprocess": ([kw, , d, , , , b]) => {
                return {
                    ...nodeData,
                    ...rangeBetween(kw, b),
                    tag: "IndexSet",
                    indices: d, condition: b
                };
            }
        },
        { "name": "iset$macrocall$5", "symbols": ["range_assign"] },
        { "name": "iset$macrocall$6", "symbols": [{ "literal": "," }] },
        { "name": "iset$macrocall$4$ebnf$1", "symbols": [] },
        { "name": "iset$macrocall$4$ebnf$1$subexpression$1", "symbols": ["_", "iset$macrocall$6", "_", "iset$macrocall$5"] },
        { "name": "iset$macrocall$4$ebnf$1", "symbols": ["iset$macrocall$4$ebnf$1", "iset$macrocall$4$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "iset$macrocall$4", "symbols": ["iset$macrocall$5", "iset$macrocall$4$ebnf$1"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "iset", "symbols": [{ "literal": "for" }, "__", "iset$macrocall$4"], "postprocess": ([kw, , d]) => {
                return {
                    ...nodeData,
                    ...rangeBetween(kw, d[d.length - 1]),
                    tag: "IndexSet",
                    indices: d, condition: undefined
                };
            }
        },
        { "name": "range_assign", "symbols": ["identifier", "_", { "literal": "in" }, "_", "int_range"], "postprocess": ([variable, , , , range]) => ({
                ...nodeData,
                ...rangeBetween(variable, range),
                tag: "RangeAssign", variable, range
            })
        },
        { "name": "int_range", "symbols": [{ "literal": "[" }, "_", "integer", "_", { "literal": "," }, "_", "integer", "_", { "literal": "]" }], "postprocess": ([lbracket, , low, , , , high, , rbracket]) => ({
                ...nodeData,
                ...rangeBetween(lbracket, rbracket),
                tag: "Range", low, high
            })
        },
        { "name": "integer", "symbols": [(lexer.has("int_literal") ? { type: "int_literal" } : int_literal)], "postprocess": ([d]) => ({
                ...nodeData,
                ...rangeOf(d),
                tag: "NumberConstant", value: +d.value
            })
        },
        { "name": "float", "symbols": [(lexer.has("float_literal") ? { type: "float_literal" } : float_literal)], "postprocess": ([d]) => ({
                ...nodeData,
                ...rangeOf(d),
                tag: "NumberConstant", value: +d.value
            })
        },
        { "name": "number", "symbols": ["integer"], "postprocess": id },
        { "name": "number", "symbols": ["float"], "postprocess": id },
        { "name": "stmt", "symbols": ["decl"], "postprocess": id },
        { "name": "stmt", "symbols": ["bind"], "postprocess": id },
        { "name": "stmt", "symbols": ["let_bind"], "postprocess": id },
        { "name": "stmt", "symbols": ["decl_bind"], "postprocess": id },
        { "name": "stmt", "symbols": ["apply_predicate"], "postprocess": id },
        { "name": "stmt", "symbols": ["label_stmt"], "postprocess": id },
        { "name": "stmt", "symbols": ["equal_exprs"], "postprocess": id },
        { "name": "stmt", "symbols": ["equal_predicates"], "postprocess": id },
        { "name": "decl$macrocall$2", "symbols": ["identifier"] },
        { "name": "decl$macrocall$3", "symbols": [{ "literal": "," }] },
        { "name": "decl$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "decl$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "decl$macrocall$3", "_", "decl$macrocall$2"] },
        { "name": "decl$macrocall$1$ebnf$1", "symbols": ["decl$macrocall$1$ebnf$1", "decl$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "decl$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "decl$macrocall$3"] },
        { "name": "decl$macrocall$1$ebnf$2", "symbols": ["decl$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "decl$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "decl$macrocall$1", "symbols": ["decl$macrocall$2", "decl$macrocall$1$ebnf$1", "decl$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "decl", "symbols": ["type_constructor", "__", "decl$macrocall$1"], "postprocess": ([type, , ids]) => {
                if (ids.length === 1) {
                    // single identifier means one decl
                    return {
                        ...nodeData,
                        ...rangeFrom([type, ...ids]),
                        tag: "Decl",
                        type, name: ids[0]
                    };
                }
                else {
                    return {
                        ...nodeData,
                        ...rangeFrom([type, ...ids]),
                        tag: "DeclList",
                        type, names: ids
                    };
                }
            }
        },
        { "name": "bind", "symbols": ["identifier", "_", { "literal": ":=" }, "_", "sub_expr"], "postprocess": ([variable, , , , expr]) => ({
                ...nodeData,
                ...rangeBetween(variable, expr),
                tag: "Bind", variable, expr
            })
        },
        { "name": "decl_bind", "symbols": ["type_constructor", "__", "identifier", "_", { "literal": ":=" }, "_", "sub_expr"], "postprocess": ([type, , variable, , , , expr]) => {
                return {
                    ...nodeData,
                    ...rangeBetween(type, expr),
                    tag: "DeclBind",
                    type, variable, expr
                };
            }
        },
        { "name": "let_bind", "symbols": [{ "literal": "Let" }, "__", "identifier", "_", { "literal": ":=" }, "_", "sub_expr"], "postprocess": ([prefix, , variable, , , , expr]) => {
                const type = {
                    ...nodeData,
                    ...rangeBetween(variable, expr),
                    tag: "TypeConstructor", args: [], name: expr.name
                };
                return {
                    ...nodeData,
                    ...rangeBetween(type, expr),
                    tag: "DeclBind",
                    type, variable, expr
                };
            }
        },
        { "name": "apply_predicate$macrocall$2", "symbols": ["pred_arg"] },
        { "name": "apply_predicate$macrocall$3", "symbols": [{ "literal": "," }] },
        { "name": "apply_predicate$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "apply_predicate$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "apply_predicate$macrocall$3", "_", "apply_predicate$macrocall$2"] },
        { "name": "apply_predicate$macrocall$1$ebnf$1", "symbols": ["apply_predicate$macrocall$1$ebnf$1", "apply_predicate$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "apply_predicate$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "apply_predicate$macrocall$3"] },
        { "name": "apply_predicate$macrocall$1$ebnf$2", "symbols": ["apply_predicate$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "apply_predicate$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "apply_predicate$macrocall$1", "symbols": ["apply_predicate$macrocall$2", "apply_predicate$macrocall$1$ebnf$1", "apply_predicate$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "apply_predicate", "symbols": ["identifier", "_", { "literal": "(" }, "_", "apply_predicate$macrocall$1", "_", { "literal": ")" }], "postprocess": ([name, , , , args]) => ({
                ...nodeData,
                ...rangeFrom([name, ...args]),
                tag: "ApplyPredicate", name, args
            })
        },
        { "name": "pred_arg", "symbols": ["sub_expr"], "postprocess": id },
        { "name": "sub_expr", "symbols": ["identifier"], "postprocess": id },
        { "name": "sub_expr", "symbols": ["deconstructor"], "postprocess": id },
        { "name": "sub_expr", "symbols": ["func"], "postprocess": id },
        { "name": "sub_expr", "symbols": ["string_lit"], "postprocess": id },
        { "name": "deconstructor", "symbols": ["identifier", "_", { "literal": "." }, "_", "identifier"], "postprocess": ([variable, , , , field]) => ({
                ...nodeData,
                ...rangeBetween(variable, field),
                tag: "Deconstructor", variable, field
            })
        },
        { "name": "func$macrocall$2", "symbols": ["sub_expr"] },
        { "name": "func$macrocall$3", "symbols": [{ "literal": "," }] },
        { "name": "func$macrocall$1", "symbols": [], "postprocess": d => [] },
        { "name": "func$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "func$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "func$macrocall$3", "_", "func$macrocall$2"] },
        { "name": "func$macrocall$1$ebnf$1", "symbols": ["func$macrocall$1$ebnf$1", "func$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "func$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "func$macrocall$3"] },
        { "name": "func$macrocall$1$ebnf$2", "symbols": ["func$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "func$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "func$macrocall$1", "symbols": ["func$macrocall$2", "func$macrocall$1$ebnf$1", "func$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "func", "symbols": ["identifier", "_", { "literal": "(" }, "_", "func$macrocall$1", "_", { "literal": ")" }], "postprocess": ([name, , , , args]) => ({
                ...nodeData,
                ...rangeFrom([name, ...args]),
                tag: "Func", name, args
            })
        },
        { "name": "equal_exprs", "symbols": ["sub_expr", "_", { "literal": "=" }, "_", "sub_expr"], "postprocess": ([left, , , , right]) => ({
                ...nodeData,
                ...rangeBetween(left, right),
                tag: "EqualExprs", left, right
            })
        },
        { "name": "equal_predicates", "symbols": ["apply_predicate", "_", { "literal": "<->" }, "_", "apply_predicate"], "postprocess": ([left, , , , right]) => ({
                ...nodeData,
                ...rangeBetween(left, right),
                tag: "EqualPredicates", left, right
            })
        },
        { "name": "label_stmt", "symbols": ["label_decl"], "postprocess": id },
        { "name": "label_stmt", "symbols": ["no_label"], "postprocess": id },
        { "name": "label_stmt", "symbols": ["auto_label"], "postprocess": id },
        { "name": "label_decl", "symbols": [{ "literal": "Label" }, "__", "identifier", "__", "tex_literal"], "postprocess": ([kw, , variable, , label]) => ({
                ...nodeData,
                ...rangeBetween(rangeOf(kw), label),
                tag: "LabelDecl",
                labelType: "MathLabel",
                variable, label
            })
        },
        { "name": "label_decl", "symbols": [{ "literal": "Label" }, "__", "identifier", "__", "string_lit"], "postprocess": ([kw, , variable, , label]) => ({
                ...nodeData,
                ...rangeBetween(rangeOf(kw), label),
                tag: "LabelDecl",
                labelType: "TextLabel",
                variable, label
            })
        },
        { "name": "no_label$macrocall$2", "symbols": ["identifier"] },
        { "name": "no_label$macrocall$3", "symbols": [{ "literal": "," }] },
        { "name": "no_label$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "no_label$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "no_label$macrocall$3", "_", "no_label$macrocall$2"] },
        { "name": "no_label$macrocall$1$ebnf$1", "symbols": ["no_label$macrocall$1$ebnf$1", "no_label$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "no_label$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "no_label$macrocall$3"] },
        { "name": "no_label$macrocall$1$ebnf$2", "symbols": ["no_label$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "no_label$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "no_label$macrocall$1", "symbols": ["no_label$macrocall$2", "no_label$macrocall$1$ebnf$1", "no_label$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "no_label", "symbols": [{ "literal": "NoLabel" }, "__", "no_label$macrocall$1"], "postprocess": ([kw, , args]) => ({
                ...nodeData,
                ...rangeFrom([rangeOf(kw), ...args]),
                tag: "NoLabel", args
            })
        },
        { "name": "auto_label", "symbols": [{ "literal": "AutoLabel" }, "__", "label_option"], "postprocess": ([kw, , option]) => ({
                ...nodeData,
                ...rangeBetween(kw, option),
                tag: "AutoLabel", option
            })
        },
        { "name": "label_option", "symbols": [{ "literal": "All" }], "postprocess": ([kw]) => ({ ...nodeData, ...rangeOf(kw), tag: "DefaultLabels" }) },
        { "name": "label_option$macrocall$2", "symbols": ["identifier"] },
        { "name": "label_option$macrocall$3", "symbols": [{ "literal": "," }] },
        { "name": "label_option$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "label_option$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "label_option$macrocall$3", "_", "label_option$macrocall$2"] },
        { "name": "label_option$macrocall$1$ebnf$1", "symbols": ["label_option$macrocall$1$ebnf$1", "label_option$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "label_option$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "label_option$macrocall$3"] },
        { "name": "label_option$macrocall$1$ebnf$2", "symbols": ["label_option$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "label_option$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "label_option$macrocall$1", "symbols": ["label_option$macrocall$2", "label_option$macrocall$1$ebnf$1", "label_option$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "label_option", "symbols": ["label_option$macrocall$1"], "postprocess": ([variables]) => ({ ...nodeData, ...rangeFrom(variables), tag: "LabelIDs", variables })
        },
        { "name": "type_constructor$ebnf$1", "symbols": ["type_arg_list"], "postprocess": id },
        { "name": "type_constructor$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "type_constructor", "symbols": ["identifier", "type_constructor$ebnf$1"], "postprocess": ([name, a]) => {
                const args = optional(a, []);
                return {
                    ...nodeData,
                    ...rangeFrom([name, ...args]),
                    tag: "TypeConstructor", name, args
                };
            }
        },
        { "name": "type_arg_list$macrocall$2", "symbols": ["type_constructor"] },
        { "name": "type_arg_list$macrocall$3", "symbols": [{ "literal": "," }] },
        { "name": "type_arg_list$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "type_arg_list$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "type_arg_list$macrocall$3", "_", "type_arg_list$macrocall$2"] },
        { "name": "type_arg_list$macrocall$1$ebnf$1", "symbols": ["type_arg_list$macrocall$1$ebnf$1", "type_arg_list$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "type_arg_list$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "type_arg_list$macrocall$3"] },
        { "name": "type_arg_list$macrocall$1$ebnf$2", "symbols": ["type_arg_list$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "type_arg_list$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "type_arg_list$macrocall$1", "symbols": ["type_arg_list$macrocall$2", "type_arg_list$macrocall$1$ebnf$1", "type_arg_list$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "type_arg_list", "symbols": ["_", { "literal": "(" }, "_", "type_arg_list$macrocall$1", "_", { "literal": ")" }], "postprocess": ([, , , d]) => _.flatten(d)
        },
        { "name": "expr", "symbols": ["expr", "_", { "literal": "+" }, "_", "term"], "postprocess": ([left, , , , right]) => ({ ...nodeData, ...rangeBetween(left, right), tag: "BinaryExpr", operator: "+", left, right }) },
        { "name": "expr", "symbols": ["expr", "_", { "literal": "-" }, "_", "term"], "postprocess": ([left, , , , right]) => ({ ...nodeData, ...rangeBetween(left, right), tag: "BinaryExpr", operator: "-", left, right }) },
        { "name": "expr", "symbols": ["term"], "postprocess": id },
        { "name": "term", "symbols": ["term", "_", { "literal": "^" }, "_", "factor"], "postprocess": ([left, , , , right]) => ({ ...nodeData, ...rangeBetween(left, right), tag: "BinaryExpr", operator: "^", left, right }) },
        { "name": "term", "symbols": ["term", "_", { "literal": "*" }, "_", "factor"], "postprocess": ([left, , , , right]) => ({ ...nodeData, ...rangeBetween(left, right), tag: "BinaryExpr", operator: "*", left, right }) },
        { "name": "term", "symbols": ["term", "_", { "literal": "/" }, "_", "factor"], "postprocess": ([left, , , , right]) => ({ ...nodeData, ...rangeBetween(left, right), tag: "BinaryExpr", operator: "/", left, right }) },
        { "name": "term", "symbols": ["term", "_", { "literal": "%" }, "_", "factor"], "postprocess": ([left, , , , right]) => ({ ...nodeData, ...rangeBetween(left, right), tag: "BinaryExpr", operator: "%", left, right }) },
        { "name": "term", "symbols": ["term", "_", { "literal": "mod" }, "_", "factor"], "postprocess": ([left, , , , right]) => ({ ...nodeData, ...rangeBetween(left, right), tag: "BinaryExpr", operator: "%", left, right }) },
        { "name": "term", "symbols": [{ "literal": "-" }, "_", "factor"], "postprocess": ([op, , arg]) => ({ ...nodeData, ...rangeBetween(op, arg), tag: "UnaryExpr", operator: "-", arg }) },
        { "name": "term", "symbols": ["factor"], "postprocess": id },
        { "name": "factor", "symbols": [{ "literal": "(" }, "_", "expr", "_", { "literal": ")" }], "postprocess": nth(2) },
        { "name": "factor", "symbols": ["number"], "postprocess": id },
        { "name": "factor", "symbols": ["identifier"], "postprocess": id },
        { "name": "comparison_expr", "symbols": ["expr", "_", { "literal": "<" }, "_", "expr"], "postprocess": ([left, , , , right]) => ({ ...nodeData, ...rangeBetween(left, right), tag: "ComparisonExpr", operator: "<", left, right }) },
        { "name": "comparison_expr", "symbols": ["expr", "_", { "literal": ">" }, "_", "expr"], "postprocess": ([left, , , , right]) => ({ ...nodeData, ...rangeBetween(left, right), tag: "ComparisonExpr", operator: ">", left, right }) },
        { "name": "comparison_expr", "symbols": ["expr", "_", { "literal": "<=" }, "_", "expr"], "postprocess": ([left, , , , right]) => ({ ...nodeData, ...rangeBetween(left, right), tag: "ComparisonExpr", operator: "<=", left, right }) },
        { "name": "comparison_expr", "symbols": ["expr", "_", { "literal": ">=" }, "_", "expr"], "postprocess": ([left, , , , right]) => ({ ...nodeData, ...rangeBetween(left, right), tag: "ComparisonExpr", operator: ">=", left, right }) },
        { "name": "comparison_expr", "symbols": ["expr", "_", { "literal": "==" }, "_", "expr"], "postprocess": ([left, , , , right]) => ({ ...nodeData, ...rangeBetween(left, right), tag: "ComparisonExpr", operator: "==", left, right }) },
        { "name": "comparison_expr", "symbols": ["expr", "_", { "literal": "!=" }, "_", "expr"], "postprocess": ([left, , , , right]) => ({ ...nodeData, ...rangeBetween(left, right), tag: "ComparisonExpr", operator: "!=", left, right }) },
        { "name": "boolean_expr", "symbols": ["boolean_expr", "_", { "literal": "||" }, "_", "boolean_term"], "postprocess": ([left, , , , right]) => ({ ...nodeData, ...rangeBetween(left, right), tag: "BinaryBooleanExpr", operator: "||", left, right }) },
        { "name": "boolean_expr", "symbols": ["boolean_term"], "postprocess": id },
        { "name": "boolean_term", "symbols": ["boolean_term", "_", { "literal": "&&" }, "_", "boolean_factor"], "postprocess": ([left, , , , right]) => ({ ...nodeData, ...rangeBetween(left, right), tag: "BinaryBooleanExpr", operator: "&&", left, right }) },
        { "name": "boolean_term", "symbols": [{ "literal": "!" }, "_", "boolean_factor"], "postprocess": ([op, , arg]) => ({ ...nodeData, ...rangeBetween(op, arg), tag: "UnaryBooleanExpr", operator: "!", arg }) },
        { "name": "boolean_term", "symbols": ["boolean_factor"], "postprocess": id },
        { "name": "boolean_factor", "symbols": [{ "literal": "(" }, "_", "boolean_expr", "_", { "literal": ")" }], "postprocess": nth(2) },
        { "name": "boolean_factor", "symbols": [{ "literal": "true" }], "postprocess": ([kw]) => ({ ...nodeData, ...rangeOf(kw), tag: "BooleanConstant", value: true }) },
        { "name": "boolean_factor", "symbols": [{ "literal": "false" }], "postprocess": ([kw]) => ({ ...nodeData, ...rangeOf(kw), tag: "BooleanConstant", value: false }) },
        { "name": "boolean_factor", "symbols": ["comparison_expr"], "postprocess": id },
        { "name": "string_lit", "symbols": [(lexer.has("string_literal") ? { type: "string_literal" } : string_literal)], "postprocess": ([d]) => ({
                ...nodeData,
                ...rangeOf(d),
                tag: 'StringLit',
                contents: d.value
            })
        },
        { "name": "tex_literal", "symbols": [(lexer.has("tex_literal") ? { type: "tex_literal" } : tex_literal)], "postprocess": ([d]) => ({
                ...nodeData,
                ...rangeOf(d),
                tag: 'StringLit',
                contents: d.text.substring(1, d.text.length - 1), // NOTE: remove dollars
            })
        },
        { "name": "identifier", "symbols": [(lexer.has("identifier") ? { type: "identifier" } : identifier)], "postprocess": ([d]) => ({
                ...nodeData,
                ...rangeOf(d),
                tag: 'Identifier',
                value: d.text,
                type: "identifier"
            })
        },
        { "name": "comment", "symbols": [(lexer.has("comment") ? { type: "comment" } : comment)], "postprocess": convertTokenId },
        { "name": "comment", "symbols": [(lexer.has("multiline_comment") ? { type: "multiline_comment" } : multiline_comment)], "postprocess": ([d]) => rangeOf(d) },
        { "name": "_c_$ebnf$1", "symbols": [] },
        { "name": "_c_$ebnf$1$subexpression$1", "symbols": [(lexer.has("ws") ? { type: "ws" } : ws)] },
        { "name": "_c_$ebnf$1$subexpression$1", "symbols": ["comment"] },
        { "name": "_c_$ebnf$1", "symbols": ["_c_$ebnf$1", "_c_$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "_c_", "symbols": ["_c_$ebnf$1"] },
        { "name": "_ml$ebnf$1", "symbols": [] },
        { "name": "_ml$ebnf$1", "symbols": ["_ml$ebnf$1", "multi_line_ws_char"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "_ml", "symbols": ["_ml$ebnf$1"] },
        { "name": "multi_line_ws_char", "symbols": [(lexer.has("ws") ? { type: "ws" } : ws)] },
        { "name": "multi_line_ws_char", "symbols": [(lexer.has("nl") ? { type: "nl" } : nl)] },
        { "name": "multi_line_ws_char", "symbols": ["comment"] },
        { "name": "nl", "symbols": [(lexer.has("nl") ? { type: "nl" } : nl)] },
        { "name": "__$ebnf$1", "symbols": [(lexer.has("ws") ? { type: "ws" } : ws)] },
        { "name": "__$ebnf$1", "symbols": ["__$ebnf$1", (lexer.has("ws") ? { type: "ws" } : ws)], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "__", "symbols": ["__$ebnf$1"] },
        { "name": "_$ebnf$1", "symbols": [] },
        { "name": "_$ebnf$1", "symbols": ["_$ebnf$1", (lexer.has("ws") ? { type: "ws" } : ws)], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "_", "symbols": ["_$ebnf$1"] }
    ],
    ParserStart: "input",
};
export default grammar;
//# sourceMappingURL=SubstanceParser.js.map