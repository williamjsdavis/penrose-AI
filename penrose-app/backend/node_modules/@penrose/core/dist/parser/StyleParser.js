// Generated automatically by nearley, version 2.20.1
// http://github.com/Hardmath123/nearley
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function id(d) { return d[0]; }
/* eslint-disable */
import moo from "moo";
import _ from 'lodash';
import { basicSymbols, rangeOf, rangeBetween, rangeFrom, nth, convertTokenId } from './ParserUtil.js';
const styleTypes = ["scalar",
    "int",
    "bool",
    "string",
    "path",
    "color",
    "file",
    "style",
    "shape" // TODO: make sure this is the intended keyword
    ,
    "list",
    "vec2",
    "vec3",
    "vec4",
    "mat2x2",
    "mat3x3",
    "mat4x4",
    "function",
    "objective",
    "constraint"
];
// NOTE: ordering matters here. Top patterns get matched __first__
const lexer = moo.compile({
    ...basicSymbols,
    identifier: {
        // Allow latin/greek upper/lower characters, numbers, underscores.  An identified name:
        //  - May not begin with a number (ending with a number is ok)
        //  - May be a single latin/greek upper/lower character or underscore
        //  - May begin or end with an underscore
        match: /[A-Za-z_\u0374-\u03FF][A-Za-z_0-9\u0374-\u03FF]*/,
        type: moo.keywords({
            // NOTE: the next line add type annotation keywords into the keyword set and thereby forbidding users to use keywords like `shape`
            // "type-keyword": styleTypes, 
            forall: "forall",
            foreach: "foreach",
            collect: "collect",
            where: "where",
            with: "with",
            groupby: "groupby",
            from: "from",
            listof: "listof",
            numberof: "numberof",
            nameof: "nameof",
            delete: "delete",
            as: "as",
            true: "true",
            false: "false",
            layer: "layer",
            encourage: "encourage",
            ensure: "ensure",
            override: "override",
            in: "in",
            except: "except",
            repeatable: "repeatable"
        })
    }
});
const nodeData = { nodeType: "Style" };
// Node constructors
const decl = (t, i) => ({
    ...nodeData,
    ...rangeFrom([t, i]),
    tag: "DeclPattern",
    type: t,
    id: i
});
const declList = (type, ids) => {
    return ids.map((i) => decl(type, i));
};
const selector = (repeatable, hd, wth, whr, namespace) => {
    return {
        ...nodeData,
        ...rangeFrom(_.compact([hd, wth, whr])),
        tag: "Selector",
        repeatable: repeatable ? true : false,
        head: hd,
        with: wth,
        where: whr,
    };
};
const collector = (repeatable, hd, it, whr, wth, fe) => {
    return {
        ...nodeData,
        ...rangeFrom(_.compact([hd, it, whr, wth, fe])),
        tag: "Collector",
        repeatable: repeatable ? true : false,
        head: hd,
        into: it,
        where: whr,
        with: wth,
        foreach: fe
    };
};
const layering = (kw, left, layeringOp, right) => ({
    ...nodeData,
    ...rangeFrom(kw ? [rangeOf(kw), left, ...right] : [left, ...right]),
    tag: 'Layering', left, right, layeringOp
});
const binop = (op, left, right) => ({
    ...nodeData,
    ...rangeBetween(left, right),
    tag: 'BinOp', op, left, right
});
;
;
;
;
const grammar = {
    Lexer: lexer,
    ParserRules: [
        { "name": "input", "symbols": ["_ml", "items"], "postprocess": ([, items]) => ({
                ...nodeData,
                ...rangeFrom(items),
                tag: "StyProg", items
            })
        },
        { "name": "items$ebnf$1", "symbols": [] },
        { "name": "items$ebnf$1", "symbols": ["items$ebnf$1", "item"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "items", "symbols": ["items$ebnf$1"], "postprocess": id },
        { "name": "item", "symbols": ["header", "block", "_ml"], "postprocess": ([header, block]) => ({
                ...nodeData,
                ...rangeFrom([header, block]),
                tag: "HeaderBlock", header, block
            })
        },
        { "name": "item", "symbols": [{ "literal": "layout" }, "_", { "literal": "=" }, "_", "stage_list", "_ml"], "postprocess": ([kw, , , , stages]) => ({
                ...nodeData,
                ...rangeBetween(kw, stages[stages.length - 1]),
                tag: "LayoutStages",
                contents: stages
            })
        },
        { "name": "header", "symbols": ["selector"], "postprocess": id },
        { "name": "header", "symbols": ["collector"], "postprocess": id },
        { "name": "header", "symbols": ["namespace"], "postprocess": id },
        { "name": "selector$ebnf$1$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "selector$ebnf$1", "symbols": ["selector$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "selector$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "selector", "symbols": ["forall", "selector$ebnf$1", "decl_patterns", "_ml"], "postprocess": (d) => selector(d[1], d[2], undefined, undefined) },
        { "name": "selector$ebnf$2$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "selector$ebnf$2", "symbols": ["selector$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "selector$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "selector", "symbols": ["forall", "selector$ebnf$2", "decl_patterns", "_ml", "select_where"], "postprocess": (d) => selector(d[1], d[2], undefined, d[4]) },
        { "name": "selector$ebnf$3$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "selector$ebnf$3", "symbols": ["selector$ebnf$3$subexpression$1"], "postprocess": id },
        { "name": "selector$ebnf$3", "symbols": [], "postprocess": () => null },
        { "name": "selector", "symbols": ["forall", "selector$ebnf$3", "decl_patterns", "_ml", "select_with"], "postprocess": (d) => selector(d[1], d[2], d[4], undefined) },
        { "name": "selector$ebnf$4$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "selector$ebnf$4", "symbols": ["selector$ebnf$4$subexpression$1"], "postprocess": id },
        { "name": "selector$ebnf$4", "symbols": [], "postprocess": () => null },
        { "name": "selector", "symbols": ["forall", "selector$ebnf$4", "decl_patterns", "_ml", "select_where", "select_with"], "postprocess": (d) => selector(d[1], d[2], d[5], d[4]) },
        { "name": "selector$ebnf$5$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "selector$ebnf$5", "symbols": ["selector$ebnf$5$subexpression$1"], "postprocess": id },
        { "name": "selector$ebnf$5", "symbols": [], "postprocess": () => null },
        { "name": "selector", "symbols": ["forall", "selector$ebnf$5", "decl_patterns", "_ml", "select_with", "select_where"], "postprocess": (d) => selector(d[1], d[2], d[4], d[5]) },
        { "name": "collector$ebnf$1$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "collector$ebnf$1", "symbols": ["collector$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "collector$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "collector", "symbols": ["collect", "collector$ebnf$1", "decl", "_ml", "into", "_ml"], "postprocess": (d) => collector(d[1], d[2], d[4], undefined, undefined, undefined) },
        { "name": "collector$ebnf$2$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "collector$ebnf$2", "symbols": ["collector$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "collector$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "collector", "symbols": ["collect", "collector$ebnf$2", "decl", "_ml", "into", "_ml", "select_where"], "postprocess": (d) => collector(d[1], d[2], d[4], d[6], undefined, undefined) },
        { "name": "collector$ebnf$3$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "collector$ebnf$3", "symbols": ["collector$ebnf$3$subexpression$1"], "postprocess": id },
        { "name": "collector$ebnf$3", "symbols": [], "postprocess": () => null },
        { "name": "collector", "symbols": ["collect", "collector$ebnf$3", "decl", "_ml", "into", "_ml", "select_where", "select_with"], "postprocess": (d) => collector(d[1], d[2], d[4], d[6], d[7], undefined) },
        { "name": "collector$ebnf$4$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "collector$ebnf$4", "symbols": ["collector$ebnf$4$subexpression$1"], "postprocess": id },
        { "name": "collector$ebnf$4", "symbols": [], "postprocess": () => null },
        { "name": "collector", "symbols": ["collect", "collector$ebnf$4", "decl", "_ml", "into", "_ml", "select_where", "select_with", "foreach"], "postprocess": (d) => collector(d[1], d[2], d[4], d[6], d[7], d[8]) },
        { "name": "collector$ebnf$5$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "collector$ebnf$5", "symbols": ["collector$ebnf$5$subexpression$1"], "postprocess": id },
        { "name": "collector$ebnf$5", "symbols": [], "postprocess": () => null },
        { "name": "collector", "symbols": ["collect", "collector$ebnf$5", "decl", "_ml", "into", "_ml", "select_where", "foreach"], "postprocess": (d) => collector(d[1], d[2], d[4], d[6], undefined, d[7]) },
        { "name": "collector$ebnf$6$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "collector$ebnf$6", "symbols": ["collector$ebnf$6$subexpression$1"], "postprocess": id },
        { "name": "collector$ebnf$6", "symbols": [], "postprocess": () => null },
        { "name": "collector", "symbols": ["collect", "collector$ebnf$6", "decl", "_ml", "into", "_ml", "select_where", "foreach", "select_with"], "postprocess": (d) => collector(d[1], d[2], d[4], d[6], d[8], d[7]) },
        { "name": "collector$ebnf$7$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "collector$ebnf$7", "symbols": ["collector$ebnf$7$subexpression$1"], "postprocess": id },
        { "name": "collector$ebnf$7", "symbols": [], "postprocess": () => null },
        { "name": "collector", "symbols": ["collect", "collector$ebnf$7", "decl", "_ml", "into", "_ml", "select_with"], "postprocess": (d) => collector(d[1], d[2], d[4], undefined, d[6], undefined) },
        { "name": "collector$ebnf$8$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "collector$ebnf$8", "symbols": ["collector$ebnf$8$subexpression$1"], "postprocess": id },
        { "name": "collector$ebnf$8", "symbols": [], "postprocess": () => null },
        { "name": "collector", "symbols": ["collect", "collector$ebnf$8", "decl", "_ml", "into", "_ml", "select_with", "select_where"], "postprocess": (d) => collector(d[1], d[2], d[4], d[7], d[6], undefined) },
        { "name": "collector$ebnf$9$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "collector$ebnf$9", "symbols": ["collector$ebnf$9$subexpression$1"], "postprocess": id },
        { "name": "collector$ebnf$9", "symbols": [], "postprocess": () => null },
        { "name": "collector", "symbols": ["collect", "collector$ebnf$9", "decl", "_ml", "into", "_ml", "select_with", "select_where", "foreach"], "postprocess": (d) => collector(d[1], d[2], d[4], d[7], d[6], d[8]) },
        { "name": "collector$ebnf$10$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "collector$ebnf$10", "symbols": ["collector$ebnf$10$subexpression$1"], "postprocess": id },
        { "name": "collector$ebnf$10", "symbols": [], "postprocess": () => null },
        { "name": "collector", "symbols": ["collect", "collector$ebnf$10", "decl", "_ml", "into", "_ml", "select_with", "foreach"], "postprocess": (d) => collector(d[1], d[2], d[4], undefined, d[6], d[7]) },
        { "name": "collector$ebnf$11$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "collector$ebnf$11", "symbols": ["collector$ebnf$11$subexpression$1"], "postprocess": id },
        { "name": "collector$ebnf$11", "symbols": [], "postprocess": () => null },
        { "name": "collector", "symbols": ["collect", "collector$ebnf$11", "decl", "_ml", "into", "_ml", "select_with", "foreach", "select_where"], "postprocess": (d) => collector(d[1], d[2], d[4], d[8], d[6], d[7]) },
        { "name": "collector$ebnf$12$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "collector$ebnf$12", "symbols": ["collector$ebnf$12$subexpression$1"], "postprocess": id },
        { "name": "collector$ebnf$12", "symbols": [], "postprocess": () => null },
        { "name": "collector", "symbols": ["collect", "collector$ebnf$12", "decl", "_ml", "into", "_ml", "foreach"], "postprocess": (d) => collector(d[1], d[2], d[4], undefined, undefined, d[6]) },
        { "name": "collector$ebnf$13$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "collector$ebnf$13", "symbols": ["collector$ebnf$13$subexpression$1"], "postprocess": id },
        { "name": "collector$ebnf$13", "symbols": [], "postprocess": () => null },
        { "name": "collector", "symbols": ["collect", "collector$ebnf$13", "decl", "_ml", "into", "_ml", "foreach", "select_where"], "postprocess": (d) => collector(d[1], d[2], d[4], d[7], undefined, d[6]) },
        { "name": "collector$ebnf$14$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "collector$ebnf$14", "symbols": ["collector$ebnf$14$subexpression$1"], "postprocess": id },
        { "name": "collector$ebnf$14", "symbols": [], "postprocess": () => null },
        { "name": "collector", "symbols": ["collect", "collector$ebnf$14", "decl", "_ml", "into", "_ml", "foreach", "select_where", "select_with"], "postprocess": (d) => collector(d[1], d[2], d[4], d[7], d[8], d[6]) },
        { "name": "collector$ebnf$15$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "collector$ebnf$15", "symbols": ["collector$ebnf$15$subexpression$1"], "postprocess": id },
        { "name": "collector$ebnf$15", "symbols": [], "postprocess": () => null },
        { "name": "collector", "symbols": ["collect", "collector$ebnf$15", "decl", "_ml", "into", "_ml", "foreach", "select_with"], "postprocess": (d) => collector(d[1], d[2], d[4], undefined, d[7], d[6]) },
        { "name": "collector$ebnf$16$subexpression$1", "symbols": [{ "literal": "repeatable" }, "__"] },
        { "name": "collector$ebnf$16", "symbols": ["collector$ebnf$16$subexpression$1"], "postprocess": id },
        { "name": "collector$ebnf$16", "symbols": [], "postprocess": () => null },
        { "name": "collector", "symbols": ["collect", "collector$ebnf$16", "decl", "_ml", "into", "_ml", "foreach", "select_with", "select_where"], "postprocess": (d) => collector(d[1], d[2], d[4], d[8], d[7], d[6]) },
        { "name": "into", "symbols": [{ "literal": "into" }, "__", "binding_form"], "postprocess": nth(2) },
        { "name": "forall", "symbols": [{ "literal": "forall" }, "__"], "postprocess": nth(0) },
        { "name": "collect", "symbols": [{ "literal": "collect" }, "__"], "postprocess": nth(0) },
        { "name": "select_with", "symbols": [{ "literal": "with" }, "__", "decl_patterns", "_ml"], "postprocess": d => d[2] },
        { "name": "foreach", "symbols": [{ "literal": "foreach" }, "__", "decl_patterns", "_ml"], "postprocess": d => d[2] },
        { "name": "decl_patterns$macrocall$2", "symbols": ["decl_list"] },
        { "name": "decl_patterns$macrocall$3", "symbols": [{ "literal": ";" }] },
        { "name": "decl_patterns$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "decl_patterns$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "decl_patterns$macrocall$3", "_", "decl_patterns$macrocall$2"] },
        { "name": "decl_patterns$macrocall$1$ebnf$1", "symbols": ["decl_patterns$macrocall$1$ebnf$1", "decl_patterns$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "decl_patterns$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "decl_patterns$macrocall$3"] },
        { "name": "decl_patterns$macrocall$1$ebnf$2", "symbols": ["decl_patterns$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "decl_patterns$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "decl_patterns$macrocall$1", "symbols": ["decl_patterns$macrocall$2", "decl_patterns$macrocall$1$ebnf$1", "decl_patterns$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "decl_patterns", "symbols": ["decl_patterns$macrocall$1"], "postprocess": ([d]) => {
                const contents = _.flatten(d);
                return {
                    ...nodeData,
                    ...rangeFrom(contents),
                    tag: "DeclPatterns", contents
                };
            }
        },
        { "name": "decl_list$macrocall$2", "symbols": ["binding_form"] },
        { "name": "decl_list$macrocall$3", "symbols": [{ "literal": "," }] },
        { "name": "decl_list$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "decl_list$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "decl_list$macrocall$3", "_", "decl_list$macrocall$2"] },
        { "name": "decl_list$macrocall$1$ebnf$1", "symbols": ["decl_list$macrocall$1$ebnf$1", "decl_list$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "decl_list$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "decl_list$macrocall$3"] },
        { "name": "decl_list$macrocall$1$ebnf$2", "symbols": ["decl_list$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "decl_list$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "decl_list$macrocall$1", "symbols": ["decl_list$macrocall$2", "decl_list$macrocall$1$ebnf$1", "decl_list$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "decl_list", "symbols": ["identifier", "__", "decl_list$macrocall$1"], "postprocess": ([type, , ids]) => {
                return declList(type, ids);
            }
        },
        { "name": "decl", "symbols": ["identifier", "__", "binding_form"], "postprocess": ([type, , id]) => {
                return decl(type, id);
            }
        },
        { "name": "select_where", "symbols": [{ "literal": "where" }, "__", "relation_list", "_ml"], "postprocess": d => d[2] },
        { "name": "relation_list$macrocall$2", "symbols": ["relation"] },
        { "name": "relation_list$macrocall$3", "symbols": [{ "literal": ";" }] },
        { "name": "relation_list$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "relation_list$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "relation_list$macrocall$3", "_", "relation_list$macrocall$2"] },
        { "name": "relation_list$macrocall$1$ebnf$1", "symbols": ["relation_list$macrocall$1$ebnf$1", "relation_list$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "relation_list$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "relation_list$macrocall$3"] },
        { "name": "relation_list$macrocall$1$ebnf$2", "symbols": ["relation_list$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "relation_list$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "relation_list$macrocall$1", "symbols": ["relation_list$macrocall$2", "relation_list$macrocall$1$ebnf$1", "relation_list$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "relation_list", "symbols": ["relation_list$macrocall$1"], "postprocess": ([d]) => ({
                ...nodeData,
                ...rangeFrom(d),
                tag: "RelationPatterns",
                contents: d
            })
        },
        { "name": "relation", "symbols": ["rel_bind"], "postprocess": id },
        { "name": "relation", "symbols": ["rel_pred"], "postprocess": id },
        { "name": "relation", "symbols": ["rel_field"], "postprocess": id },
        { "name": "rel_bind", "symbols": ["binding_form", "_", { "literal": ":=" }, "_", "sel_expr"], "postprocess": ([id, , , , expr]) => ({
                ...nodeData,
                ...rangeFrom([id, expr]),
                tag: "RelBind", id, expr,
            })
        },
        { "name": "rel_pred", "symbols": ["identifier", "_", { "literal": "(" }, "pred_arg_list", { "literal": ")" }, "__ml", "alias_as"], "postprocess": // aliasing case
            ([name, , , args, , , a]) => ({
                ...nodeData,
                ...rangeFrom([name, ...args, a]),
                tag: "RelPred", name, args, alias: a
            })
        },
        { "name": "rel_pred", "symbols": ["identifier", "_", { "literal": "(" }, "pred_arg_list", { "literal": ")" }], "postprocess": ([name, , , args, ,]) => ({
                ...nodeData,
                ...rangeFrom([name, ...args]),
                tag: "RelPred", name, args,
            })
        },
        { "name": "alias_as", "symbols": [{ "literal": "as" }, "__", "identifier"], "postprocess": d => d[2] },
        { "name": "rel_field$ebnf$1$subexpression$1", "symbols": ["field_desc", "__"] },
        { "name": "rel_field$ebnf$1", "symbols": ["rel_field$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "rel_field$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "rel_field", "symbols": ["binding_form", "__", { "literal": "has" }, "__", "rel_field$ebnf$1", "identifier"], "postprocess": ([name, , , , field_desc, field]) => ({
                ...nodeData,
                ...rangeBetween(name, field),
                tag: "RelField",
                fieldDescriptor: field_desc ? field_desc[0] : undefined,
                name, field,
            })
        },
        { "name": "field_desc", "symbols": [{ "literal": "math" }], "postprocess": () => "MathLabel" },
        { "name": "field_desc", "symbols": [{ "literal": "text" }], "postprocess": () => "TextLabel" },
        { "name": "sel_expr_list", "symbols": ["_"], "postprocess": d => [] },
        { "name": "sel_expr_list$macrocall$2", "symbols": ["sel_expr"] },
        { "name": "sel_expr_list$macrocall$3", "symbols": [{ "literal": "," }] },
        { "name": "sel_expr_list$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "sel_expr_list$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "sel_expr_list$macrocall$3", "_", "sel_expr_list$macrocall$2"] },
        { "name": "sel_expr_list$macrocall$1$ebnf$1", "symbols": ["sel_expr_list$macrocall$1$ebnf$1", "sel_expr_list$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "sel_expr_list$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "sel_expr_list$macrocall$3"] },
        { "name": "sel_expr_list$macrocall$1$ebnf$2", "symbols": ["sel_expr_list$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "sel_expr_list$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "sel_expr_list$macrocall$1", "symbols": ["sel_expr_list$macrocall$2", "sel_expr_list$macrocall$1$ebnf$1", "sel_expr_list$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "sel_expr_list", "symbols": ["_", "sel_expr_list$macrocall$1", "_"], "postprocess": nth(1) },
        { "name": "sel_expr", "symbols": ["identifier", "_", { "literal": "(" }, "sel_expr_list", { "literal": ")" }], "postprocess": ([name, , , args,]) => ({
                ...nodeData,
                ...rangeFrom([name, ...args]),
                tag: "SEFuncOrValCons",
                name, args
            })
        },
        { "name": "sel_expr", "symbols": ["binding_form"], "postprocess": ([d]) => ({
                ...nodeData,
                ...rangeFrom([d]),
                tag: "SEBind", contents: d
            })
        },
        { "name": "pred_arg_list", "symbols": ["_"], "postprocess": d => [] },
        { "name": "pred_arg_list$macrocall$2", "symbols": ["pred_arg"] },
        { "name": "pred_arg_list$macrocall$3", "symbols": [{ "literal": "," }] },
        { "name": "pred_arg_list$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "pred_arg_list$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "pred_arg_list$macrocall$3", "_", "pred_arg_list$macrocall$2"] },
        { "name": "pred_arg_list$macrocall$1$ebnf$1", "symbols": ["pred_arg_list$macrocall$1$ebnf$1", "pred_arg_list$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "pred_arg_list$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "pred_arg_list$macrocall$3"] },
        { "name": "pred_arg_list$macrocall$1$ebnf$2", "symbols": ["pred_arg_list$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "pred_arg_list$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "pred_arg_list$macrocall$1", "symbols": ["pred_arg_list$macrocall$2", "pred_arg_list$macrocall$1$ebnf$1", "pred_arg_list$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "pred_arg_list", "symbols": ["_", "pred_arg_list$macrocall$1", "_"], "postprocess": nth(1) },
        { "name": "pred_arg", "symbols": ["rel_pred"], "postprocess": id },
        { "name": "pred_arg", "symbols": ["binding_form"], "postprocess": ([d]) => ({
                ...nodeData,
                ...rangeFrom([d]),
                tag: "SEBind", contents: d
            })
        },
        { "name": "binding_form", "symbols": ["subVar"], "postprocess": id },
        { "name": "binding_form", "symbols": ["styVar"], "postprocess": id },
        { "name": "subVar", "symbols": [{ "literal": "`" }, "identifier", { "literal": "`" }], "postprocess": ([ltick, contents, rtick]) => ({
                ...nodeData,
                ...rangeBetween(rangeOf(ltick), rangeOf(rtick)),
                tag: "SubVar", contents
            })
        },
        { "name": "styVar", "symbols": ["identifier"], "postprocess": ([contents]) => ({
                ...nodeData,
                ...rangeOf(contents),
                tag: "StyVar", contents
            })
        },
        { "name": "namespace", "symbols": ["styVar", "_ml"], "postprocess": ([contents]) => ({
                ...nodeData,
                ...rangeOf(contents),
                tag: "Namespace",
                contents
            })
        },
        { "name": "block", "symbols": [{ "literal": "{" }, "statements", { "literal": "}" }], "postprocess": ([lbrace, stmts, rbrace]) => ({
                ...nodeData,
                ...rangeBetween(lbrace, rbrace),
                tag: "Block",
                statements: stmts
            })
        },
        { "name": "statements", "symbols": ["_"], "postprocess": () => [] },
        { "name": "statements", "symbols": ["_c_", "nl", "statements"], "postprocess": nth(2) },
        { "name": "statements", "symbols": ["_", "statement", "_"], "postprocess": d => [d[1]] },
        { "name": "statements", "symbols": ["_", "statement", "_c_", "nl", "statements"], "postprocess": d => [d[1], ...d[4]] },
        { "name": "statement", "symbols": ["delete"], "postprocess": id },
        { "name": "statement", "symbols": ["override"], "postprocess": id },
        { "name": "statement", "symbols": ["path_assign"], "postprocess": id },
        { "name": "statement", "symbols": ["anonymous_expr"], "postprocess": ([contents]) => ({
                ...nodeData,
                ...rangeOf(contents),
                tag: "AnonAssign", contents
            })
        },
        { "name": "delete", "symbols": [{ "literal": "delete" }, "__", "path"], "postprocess": ([kw, , contents]) => {
                return {
                    ...nodeData,
                    ...rangeBetween(rangeOf(kw), contents),
                    tag: "Delete", contents
                };
            }
        },
        { "name": "override", "symbols": [{ "literal": "override" }, "__", "path", "_", { "literal": "=" }, "_", "assign_expr"], "postprocess": ([kw, , path, , , , value]) => ({
                ...nodeData,
                ...rangeBetween(kw, value),
                tag: "Override", path, value
            })
        },
        { "name": "path_assign$ebnf$1", "symbols": ["type"], "postprocess": id },
        { "name": "path_assign$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "path_assign", "symbols": ["path_assign$ebnf$1", "__", "path", "_", { "literal": "=" }, "_", "assign_expr"], "postprocess": ([type, , path, , , , value]) => ({
                ...nodeData,
                ...rangeBetween(type ? type : path, value),
                tag: "PathAssign",
                type, path, value
            })
        },
        { "name": "type", "symbols": ["identifier"], "postprocess": ([contents]) => ({
                ...nodeData,
                ...rangeOf(contents),
                tag: 'TypeOf', contents
            })
        },
        { "name": "type", "symbols": ["identifier", { "literal": "[" }, { "literal": "]" }], "postprocess": ([contents]) => ({
                ...nodeData,
                ...rangeOf(contents),
                tag: 'ListOf', contents
            })
        },
        { "name": "path$ebnf$1", "symbols": [] },
        { "name": "path$ebnf$1$subexpression$1", "symbols": [{ "literal": "." }, "identifier"] },
        { "name": "path$ebnf$1", "symbols": ["path$ebnf$1", "path$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "path$ebnf$2$subexpression$1", "symbols": ["_", "access_ops"] },
        { "name": "path$ebnf$2", "symbols": ["path$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "path$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "path", "symbols": ["binding_form", "path$ebnf$1", "path$ebnf$2"], "postprocess": ([name, dotParts, accesses]) => {
                const members = dotParts.map((d) => d[1]);
                const indices = accesses === null ? [] : accesses[1];
                return {
                    ...nodeData,
                    ...rangeFrom([name, ...members, ...indices]),
                    tag: "Path", name, members, indices
                };
            }
        },
        { "name": "access_ops", "symbols": ["access_op"] },
        { "name": "access_ops", "symbols": ["access_op", "_", "access_ops"], "postprocess": (d) => [d[0], ...d[2]] },
        { "name": "access_op", "symbols": [{ "literal": "[" }, "_", "expr", "_", { "literal": "]" }], "postprocess": nth(2) },
        { "name": "assign_expr", "symbols": ["expr"], "postprocess": id },
        { "name": "assign_expr", "symbols": ["layering"], "postprocess": id },
        { "name": "assign_expr", "symbols": ["objective"], "postprocess": id },
        { "name": "assign_expr", "symbols": ["constraint"], "postprocess": id },
        { "name": "assign_expr", "symbols": ["gpi_decl"], "postprocess": id },
        { "name": "anonymous_expr", "symbols": ["layering"], "postprocess": id },
        { "name": "anonymous_expr", "symbols": ["objective"], "postprocess": id },
        { "name": "anonymous_expr", "symbols": ["constraint"], "postprocess": id },
        { "name": "anonymous_expr", "symbols": ["gpi_decl"], "postprocess": id },
        { "name": "expr", "symbols": ["arithmeticExpr"], "postprocess": id },
        { "name": "parenthesized", "symbols": [{ "literal": "(" }, "_", "arithmeticExpr", "_", { "literal": ")" }], "postprocess": nth(2) },
        { "name": "parenthesized", "symbols": ["expr_literal"], "postprocess": id },
        { "name": "unary", "symbols": [{ "literal": "-" }, "_", "parenthesized"], "postprocess": (d) => ({
                ...nodeData,
                ...rangeBetween(d[0], d[2]),
                tag: 'UOp', op: "UMinus", arg: d[2]
            })
        },
        { "name": "unary", "symbols": ["parenthesized"], "postprocess": id },
        { "name": "unary", "symbols": ["unary", "_", { "literal": "'" }], "postprocess": (d) => ({ ...nodeData, ...rangeBetween(d[0], d[2]), tag: 'UOp', op: "UTranspose", arg: d[0] }) },
        { "name": "factor", "symbols": ["unary", "_", { "literal": "^" }, "_", "factor"], "postprocess": (d) => binop('Exp', d[0], d[4]) },
        { "name": "factor", "symbols": ["unary"], "postprocess": id },
        { "name": "term", "symbols": ["term", "_", { "literal": "*" }, "_", "factor"], "postprocess": (d) => binop('Multiply', d[0], d[4]) },
        { "name": "term", "symbols": ["term", "_", { "literal": "/" }, "_", "factor"], "postprocess": (d) => binop('Divide', d[0], d[4]) },
        { "name": "term", "symbols": ["term", "_", { "literal": ".*" }, "_", "factor"], "postprocess": (d) => binop('EWMultiply', d[0], d[4]) },
        { "name": "term", "symbols": ["term", "_", { "literal": "./" }, "_", "factor"], "postprocess": (d) => binop('EWDivide', d[0], d[4]) },
        { "name": "term", "symbols": ["term", "_", { "literal": "then" }, "_", "factor"], "postprocess": (d) => binop('Multiply', d[4], d[0]) },
        { "name": "term", "symbols": ["factor"], "postprocess": id },
        { "name": "arithmeticExpr", "symbols": ["arithmeticExpr", "_", { "literal": "+" }, "_", "term"], "postprocess": (d) => binop('BPlus', d[0], d[4]) },
        { "name": "arithmeticExpr", "symbols": ["arithmeticExpr", "_", { "literal": "-" }, "_", "term"], "postprocess": (d) => binop('BMinus', d[0], d[4]) },
        { "name": "arithmeticExpr", "symbols": ["term"], "postprocess": id },
        { "name": "expr_literal", "symbols": ["bool_lit"], "postprocess": id },
        { "name": "expr_literal", "symbols": ["color_lit"], "postprocess": id },
        { "name": "expr_literal", "symbols": ["string_lit"], "postprocess": id },
        { "name": "expr_literal", "symbols": ["annotated_float"], "postprocess": id },
        { "name": "expr_literal", "symbols": ["computation_function"], "postprocess": id },
        { "name": "expr_literal", "symbols": ["sty_var_expr"], "postprocess": id },
        { "name": "expr_literal", "symbols": ["path"], "postprocess": id },
        { "name": "expr_literal", "symbols": ["list"], "postprocess": id },
        { "name": "expr_literal", "symbols": ["tuple"], "postprocess": id },
        { "name": "expr_literal", "symbols": ["vector"], "postprocess": id },
        { "name": "list", "symbols": [{ "literal": "[" }, "expr_list", { "literal": "]" }], "postprocess": ([lbracket, exprs, rbracket]) => ({
                ...nodeData,
                ...rangeBetween(lbracket, rbracket),
                tag: 'List',
                contents: exprs
            })
        },
        { "name": "tuple", "symbols": [{ "literal": "{" }, "_", "expr", "_", { "literal": "," }, "_", "expr", "_", { "literal": "}" }], "postprocess": ([lbrace, , e1, , , , e2, , rbrace]) => ({
                ...nodeData,
                ...rangeBetween(lbrace, rbrace),
                tag: 'Tuple',
                contents: [e1, e2]
            })
        },
        { "name": "vector", "symbols": [{ "literal": "(" }, "_", "expr", "_", { "literal": "," }, "expr_list", { "literal": ")" }], "postprocess": ([lparen, , first, , , rest, rparen]) => ({
                ...nodeData,
                ...rangeBetween(lparen, rparen),
                tag: 'Vector',
                contents: [first, ...rest]
            })
        },
        { "name": "bool_lit$subexpression$1", "symbols": [{ "literal": "true" }] },
        { "name": "bool_lit$subexpression$1", "symbols": [{ "literal": "false" }] },
        { "name": "bool_lit", "symbols": ["bool_lit$subexpression$1"], "postprocess": ([[d]]) => ({
                ...nodeData,
                ...rangeOf(d),
                tag: 'BoolLit',
                contents: d.text === 'true' // https://stackoverflow.com/questions/263965/how-can-i-convert-a-string-to-boolean-in-javascript
            })
        },
        { "name": "color_lit", "symbols": [(lexer.has("hex_literal") ? { type: "hex_literal" } : hex_literal)], "postprocess": ([d]) => ({
                ...nodeData,
                ...rangeOf(d),
                tag: "ColorLit",
                contents: d.text.slice(1, d.text.length)
            })
        },
        { "name": "string_lit", "symbols": [(lexer.has("string_literal") ? { type: "string_literal" } : string_literal)], "postprocess": ([d]) => ({
                ...nodeData,
                ...rangeOf(d),
                tag: 'StringLit',
                contents: d.value
            })
        },
        { "name": "number", "symbols": [(lexer.has("float_literal") ? { type: "float_literal" } : float_literal)], "postprocess": id },
        { "name": "annotated_float$ebnf$1$subexpression$1$subexpression$1", "symbols": [{ "literal": "in" }] },
        { "name": "annotated_float$ebnf$1$subexpression$1$subexpression$1", "symbols": [{ "literal": "except" }] },
        { "name": "annotated_float$ebnf$1$subexpression$1", "symbols": ["__", "annotated_float$ebnf$1$subexpression$1$subexpression$1", "__", "stage_list"] },
        { "name": "annotated_float$ebnf$1", "symbols": ["annotated_float$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "annotated_float$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "annotated_float", "symbols": [{ "literal": "?" }, "annotated_float$ebnf$1"], "postprocess": ([d, stages]) => ({
                ...nodeData,
                ...rangeOf(d),
                tag: 'Vary',
                stages: stages ? stages[3] : [],
                exclude: stages ? stages[1][0].value === "except" : true,
            })
        },
        { "name": "annotated_float", "symbols": ["number"], "postprocess": ([d]) => ({ ...nodeData, ...rangeOf(d), tag: 'Fix', contents: parseFloat(d) })
        },
        { "name": "layering$ebnf$1", "symbols": ["layer_keyword"], "postprocess": id },
        { "name": "layering$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "layering", "symbols": ["layering$ebnf$1", "path", "__", "layer_op", "__", "path_list"], "postprocess": (d) => layering(d[0], d[1], d[3], d[5]) },
        { "name": "layer_keyword", "symbols": [{ "literal": "layer" }, "__"], "postprocess": nth(0) },
        { "name": "layer_op", "symbols": [{ "literal": "below" }], "postprocess": () => "below" },
        { "name": "layer_op", "symbols": [{ "literal": "above" }], "postprocess": () => "above" },
        { "name": "path_list$macrocall$2", "symbols": ["expr"] },
        { "name": "path_list$macrocall$3", "symbols": [{ "literal": "," }] },
        { "name": "path_list$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "path_list$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "path_list$macrocall$3", "_", "path_list$macrocall$2"] },
        { "name": "path_list$macrocall$1$ebnf$1", "symbols": ["path_list$macrocall$1$ebnf$1", "path_list$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "path_list$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "path_list$macrocall$3"] },
        { "name": "path_list$macrocall$1$ebnf$2", "symbols": ["path_list$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "path_list$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "path_list$macrocall$1", "symbols": ["path_list$macrocall$2", "path_list$macrocall$1$ebnf$1", "path_list$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "path_list", "symbols": ["path_list$macrocall$1"], "postprocess": id },
        { "name": "computation_function", "symbols": ["identifier", "_", { "literal": "(" }, "expr_list", { "literal": ")" }], "postprocess": ([name, , , args, rparen]) => ({
                ...nodeData,
                ...rangeBetween(name, rparen),
                tag: "CompApp",
                name, args
            })
        },
        { "name": "sty_var_expr", "symbols": [{ "literal": "listof" }, "_", "identifier", "_", { "literal": "from" }, "_", "identifier"], "postprocess": ([kw, , field, , , , name]) => ({
                ...nodeData,
                ...rangeBetween(kw, name),
                tag: "CollectionAccess",
                name, field
            })
        },
        { "name": "sty_var_expr$subexpression$1", "symbols": [{ "literal": "numberof" }] },
        { "name": "sty_var_expr$subexpression$1", "symbols": [{ "literal": "nameof" }] },
        { "name": "sty_var_expr", "symbols": ["sty_var_expr$subexpression$1", "_", "identifier"], "postprocess": ([kw, , name]) => ({
                ...nodeData,
                ...rangeBetween(kw[0], name),
                tag: "UnaryStyVarExpr",
                op: kw[0].text,
                arg: name
            })
        },
        { "name": "stage_list", "symbols": ["identifier"], "postprocess": (d) => d },
        { "name": "stage_list$macrocall$2", "symbols": ["identifier"] },
        { "name": "stage_list$macrocall$3", "symbols": [{ "literal": "," }] },
        { "name": "stage_list$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "stage_list$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "stage_list$macrocall$3", "_", "stage_list$macrocall$2"] },
        { "name": "stage_list$macrocall$1$ebnf$1", "symbols": ["stage_list$macrocall$1$ebnf$1", "stage_list$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "stage_list$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "stage_list$macrocall$3"] },
        { "name": "stage_list$macrocall$1$ebnf$2", "symbols": ["stage_list$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "stage_list$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "stage_list$macrocall$1", "symbols": ["stage_list$macrocall$2", "stage_list$macrocall$1$ebnf$1", "stage_list$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "stage_list", "symbols": [{ "literal": "[" }, "_", "stage_list$macrocall$1", "_", { "literal": "]" }], "postprocess": nth(2) },
        { "name": "comparison_op", "symbols": [{ "literal": "==" }], "postprocess": ([op]) => ({
                ...nodeData,
                ...rangeOf(op),
                tag: "ComparisonOp",
                op: op.text
            })
        },
        { "name": "comparison_op", "symbols": [{ "literal": "<" }], "postprocess": ([op]) => ({
                ...nodeData,
                ...rangeOf(op),
                tag: "ComparisonOp",
                op: op.text
            })
        },
        { "name": "comparison_op", "symbols": [{ "literal": ">" }], "postprocess": ([op]) => ({
                ...nodeData,
                ...rangeOf(op),
                tag: "ComparisonOp",
                op: op.text
            })
        },
        { "name": "obj_constr_body", "symbols": ["identifier", "_", { "literal": "(" }, "expr_list", { "literal": ")" }], "postprocess": ([name, , , args, rparen]) => {
                return {
                    ...nodeData,
                    ...rangeBetween(name, rparen),
                    tag: "FunctionCall",
                    name, args
                };
            }
        },
        { "name": "obj_constr_body", "symbols": ["expr", "_", "comparison_op", "_", "expr"], "postprocess": ([arg1, , op, , arg2]) => {
                return {
                    ...nodeData,
                    ...rangeBetween(arg1, arg2),
                    tag: "InlineComparison",
                    op, arg1, arg2
                };
            }
        },
        { "name": "objective$ebnf$1$subexpression$1$subexpression$1", "symbols": [{ "literal": "in" }] },
        { "name": "objective$ebnf$1$subexpression$1$subexpression$1", "symbols": [{ "literal": "except" }] },
        { "name": "objective$ebnf$1$subexpression$1", "symbols": ["__", "objective$ebnf$1$subexpression$1$subexpression$1", "__", "stage_list"] },
        { "name": "objective$ebnf$1", "symbols": ["objective$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "objective$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "objective", "symbols": [{ "literal": "encourage" }, "__", "obj_constr_body", "objective$ebnf$1"], "postprocess": ([kw, , body, stages]) => {
                return {
                    ...nodeData,
                    ...rangeBetween(kw, body),
                    tag: "ObjFn",
                    stages: stages ? stages[3] : [],
                    exclude: stages ? stages[1][0].value === "except" : true,
                    body
                };
            }
        },
        { "name": "constraint$ebnf$1$subexpression$1$subexpression$1", "symbols": [{ "literal": "in" }] },
        { "name": "constraint$ebnf$1$subexpression$1$subexpression$1", "symbols": [{ "literal": "except" }] },
        { "name": "constraint$ebnf$1$subexpression$1", "symbols": ["__", "constraint$ebnf$1$subexpression$1$subexpression$1", "__", "stage_list"] },
        { "name": "constraint$ebnf$1", "symbols": ["constraint$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "constraint$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "constraint", "symbols": [{ "literal": "ensure" }, "__", "obj_constr_body", "constraint$ebnf$1"], "postprocess": ([kw, , body, stages]) => {
                return {
                    ...nodeData,
                    ...rangeBetween(kw, body),
                    tag: "ConstrFn",
                    stages: stages ? stages[3] : [],
                    exclude: stages ? stages[1][0].value === "except" : true,
                    body
                };
            }
        },
        { "name": "expr_list", "symbols": ["_"], "postprocess": d => [] },
        { "name": "expr_list$macrocall$2", "symbols": ["expr"] },
        { "name": "expr_list$macrocall$3", "symbols": [{ "literal": "," }] },
        { "name": "expr_list$macrocall$1$ebnf$1", "symbols": [] },
        { "name": "expr_list$macrocall$1$ebnf$1$subexpression$1", "symbols": ["_", "expr_list$macrocall$3", "_", "expr_list$macrocall$2"] },
        { "name": "expr_list$macrocall$1$ebnf$1", "symbols": ["expr_list$macrocall$1$ebnf$1", "expr_list$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "expr_list$macrocall$1$ebnf$2$subexpression$1", "symbols": ["_", "expr_list$macrocall$3"] },
        { "name": "expr_list$macrocall$1$ebnf$2", "symbols": ["expr_list$macrocall$1$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "expr_list$macrocall$1$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "expr_list$macrocall$1", "symbols": ["expr_list$macrocall$2", "expr_list$macrocall$1$ebnf$1", "expr_list$macrocall$1$ebnf$2"], "postprocess": ([first, rest]) => {
                const restNodes = rest.map((ts) => ts[3]);
                return _.concat(first, ...restNodes);
            }
        },
        { "name": "expr_list", "symbols": ["_", "expr_list$macrocall$1", "_"], "postprocess": nth(1) },
        { "name": "gpi_decl", "symbols": ["identifier", "_ml", { "literal": "{" }, "property_decl_list", { "literal": "}" }], "postprocess": ([shapeName, , , properties, rbrace]) => ({
                ...nodeData,
                ...rangeBetween(shapeName, rbrace),
                tag: "GPIDecl",
                shapeName, properties
            })
        },
        { "name": "property_decl_list", "symbols": ["_"], "postprocess": () => [] },
        { "name": "property_decl_list", "symbols": ["_c_", "nl", "property_decl_list"], "postprocess": nth(2) },
        { "name": "property_decl_list", "symbols": ["_", "property_decl", "_"], "postprocess": d => [d[1]] },
        { "name": "property_decl_list", "symbols": ["_", "property_decl", "_c_", "nl", "property_decl_list"], "postprocess": d => [d[1], ...d[4]] },
        { "name": "property_decl", "symbols": ["identifier", "_", { "literal": ":" }, "_", "expr"], "postprocess": ([name, , , , value]) => ({
                ...nodeData,
                ...rangeBetween(name, value),
                tag: "PropertyDecl",
                name, value
            })
        },
        { "name": "identifier", "symbols": [(lexer.has("identifier") ? { type: "identifier" } : identifier)], "postprocess": ([d]) => ({
                ...nodeData,
                ...rangeOf(d),
                tag: 'Identifier',
                value: d.text,
                type: styleTypes.includes(d.text) ? "type-keyword" : "identifier"
            })
        },
        { "name": "comment", "symbols": [(lexer.has("comment") ? { type: "comment" } : comment)], "postprocess": convertTokenId },
        { "name": "comment", "symbols": [(lexer.has("multiline_comment") ? { type: "multiline_comment" } : multiline_comment)], "postprocess": ([d]) => rangeOf(d) },
        { "name": "_c_$ebnf$1", "symbols": [] },
        { "name": "_c_$ebnf$1$subexpression$1", "symbols": [(lexer.has("ws") ? { type: "ws" } : ws)] },
        { "name": "_c_$ebnf$1$subexpression$1", "symbols": ["comment"] },
        { "name": "_c_$ebnf$1", "symbols": ["_c_$ebnf$1", "_c_$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "_c_", "symbols": ["_c_$ebnf$1"] },
        { "name": "_ml$ebnf$1", "symbols": [] },
        { "name": "_ml$ebnf$1", "symbols": ["_ml$ebnf$1", "multi_line_ws_char"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "_ml", "symbols": ["_ml$ebnf$1"] },
        { "name": "__ml$ebnf$1", "symbols": ["multi_line_ws_char"] },
        { "name": "__ml$ebnf$1", "symbols": ["__ml$ebnf$1", "multi_line_ws_char"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "__ml", "symbols": ["__ml$ebnf$1"] },
        { "name": "multi_line_ws_char", "symbols": [(lexer.has("ws") ? { type: "ws" } : ws)] },
        { "name": "multi_line_ws_char", "symbols": [(lexer.has("nl") ? { type: "nl" } : nl)] },
        { "name": "multi_line_ws_char", "symbols": ["comment"] },
        { "name": "nl", "symbols": [(lexer.has("nl") ? { type: "nl" } : nl)] },
        { "name": "__$ebnf$1", "symbols": [(lexer.has("ws") ? { type: "ws" } : ws)] },
        { "name": "__$ebnf$1", "symbols": ["__$ebnf$1", (lexer.has("ws") ? { type: "ws" } : ws)], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "__", "symbols": ["__$ebnf$1"] },
        { "name": "_$ebnf$1", "symbols": [] },
        { "name": "_$ebnf$1", "symbols": ["_$ebnf$1", (lexer.has("ws") ? { type: "ws" } : ws)], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "_", "symbols": ["_$ebnf$1"] }
    ],
    ParserStart: "input",
};
export default grammar;
//# sourceMappingURL=StyleParser.js.map